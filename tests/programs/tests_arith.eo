(include "../../signature/programs/arith.eo")
(include "../unit_test_services.eo")

; Unit tests for arith.eo programs

;---------------------------------
; $is_numeric_literal
;---------------------------------

; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)

(step test true :rule $unit_test :args (($is_numeric_literal 1) true))

(step test true :rule $unit_test :args (($is_numeric_literal 1.0) true))

(step test true :rule $unit_test :args (($is_numeric_literal 1/1) true))

(step test true :rule $unit_test :args (($is_numeric_literal -1) true))

(step test true :rule $unit_test :args (($is_numeric_literal -1.0) true))

(step test true :rule $unit_test :args (($is_numeric_literal -1/1) true))

(step test true :rule $unit_test :args (($is_numeric_literal (+ 1 2)) false))

(step test true :rule $unit_test :args (($is_numeric_literal (* 1 2)) false))

(step test true :rule $unit_test :args (($is_numeric_literal false) false))

(step test true :rule $unit_test :args (($is_numeric_literal @varlist.nil) false))

(step test true :rule $unit_test :args (($is_numeric_literal a) false))

(step test true :rule $unit_test :args (($is_numeric_literal b) false))

;---------------------------------
; $is_theory_binary_arith_op
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const f (-> Int Int))

(step test true :rule $unit_test :args (($is_theory_binary_arith_op +) true))

(step test true :rule $unit_test :args (($is_theory_binary_arith_op *) true))

(step test true :rule $unit_test :args (($is_theory_binary_arith_op -) true))

(step test true :rule $unit_test :args (($is_theory_binary_arith_op /) true))

(step test true :rule $unit_test :args (($is_theory_binary_arith_op f) false))              

;---------------------------------
; $is_addition
;---------------------------------

(step test true :rule $unit_test :args (($is_addition (+ 1 1)) true))

(step test true :rule $unit_test :args (($is_addition (+ 1 (+ 1 1))) true))

(step test true :rule $unit_test :args (($is_addition (+ (+ 1 1) 1)) true))

(step test true :rule $unit_test :args (($is_addition (+ 1.0 1.0)) true))

(step test true :rule $unit_test :args (($is_addition (* 1 2)) false))

(step test true :rule $unit_test :args (($is_addition (* (+ 1.0 1.0) 2)) false))

(step test true :rule $unit_test :args (($is_addition (- 1 2)) false))

(step test true :rule $unit_test :args (($is_addition (- 1 (+ 1.0 1.0))) false))

(step test true :rule $unit_test :args (($is_addition (/ 1 2)) false))

(step test true :rule $unit_test :args (($is_addition (- 1)) false))

(step test true :rule $unit_test :args (($is_addition true) false))

;---------------------------------
; $addition_get_lhs
;---------------------------------

(step test true :rule $unit_test :args (($addition_get_lhs (+ 1 2)) 1))

(step test true :rule $unit_test :args (($addition_get_lhs (+ 1.0 2.0)) 1.0))

(step test true :rule $unit_test :args (($addition_get_lhs (+ 1/1 13.0)) 1/1))

(step test true :rule $unit_test :args (($addition_get_lhs (+ (+ 1/1 1.0) 11)) 
                                        (+ 1/1 1.0)))

(step test true :rule $unit_test :args (($addition_get_lhs (+ (+ 1/1 19) (+ 1/1 1.0))) 
                                        (+ 1/1 19)))

; Things that do not satisfy the pre.
;; (step test true :rule $unit_test :args (($addition_get_lhs (* 1.0 2.0))
;;                                         ($addition_get_lhs (* 1.0 2.0))))

;; (step test true :rule $unit_test :args (($addition_get_lhs +) 
;;                                         ($addition_get_lhs +)))

;---------------------------------
; $addition_get_rhs
;---------------------------------

(step test true :rule $unit_test :args (($addition_get_rhs ($f_list_cons + 1 2)) 
                                        2))

(step test true :rule $unit_test :args (($addition_get_rhs ($f_list_cons + 1.0 2.0)) 
                                        2.0))

(step test true :rule $unit_test :args (($addition_get_rhs ($f_list_cons + 1/1 13.0)) 
                                        13.0))

(step test true :rule $unit_test :args (($addition_get_rhs 
                                         ($f_list_cons + 3 ($f_list_cons + 1/1 1.0))) 
                                        ($f_list_cons + 1/1 1.0)))

(step test true :rule $unit_test :args (($addition_get_rhs 
                                         ($f_list_cons + 
                                                       (+ 1/1 19) 
                                                       ($f_list_cons + 1/1 1.0)))
                                        ($f_list_cons + 1/1 1.0)))

; Things that do not satisfy the pre.
;; (step test true :rule $unit_test :args (($addition_get_rhs (* 1.0 2.0)) 
;;                                         ($addition_get_rhs (* 1.0 2.0))))

;; (step test true :rule $unit_test :args (($addition_get_rhs +) 
;;                                         ($addition_get_rhs +)))

;---------------------------------
; $is_uninterpreted_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Real Real))

(step test true :rule $unit_test :args (($is_uninterpreted_term a) true))

(step test true :rule $unit_test :args (($is_uninterpreted_term b) true))

(step test true :rule $unit_test :args (($is_uninterpreted_term f) true))

(step test true :rule $unit_test :args (($is_uninterpreted_term (f 1)) true))

(step test true :rule $unit_test :args (($is_uninterpreted_term (f b)) true))

(step test true :rule $unit_test :args (($is_uninterpreted_term (f (f b))) true))

(step test true :rule $unit_test :args (($is_uninterpreted_term 12) false))

(step test true :rule $unit_test :args (($is_uninterpreted_term (+ 1 a)) false))

(step test true :rule $unit_test :args (($is_uninterpreted_term (* 1 b)) false))

(step test true :rule $unit_test :args (($is_uninterpreted_term (* 1 (+ 1 a))) false))

(step test true :rule $unit_test :args (($is_uninterpreted_term (to_int 1.0)) false))

(step test true :rule $unit_test :args (($is_uninterpreted_term (to_real 1)) false))

;---------------------------------
; $is_evaluatable
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const f (-> Real Real))

(step test true :rule $unit_test :args (($is_evaluatable 1) true))

(step test true :rule $unit_test :args (($is_evaluatable -1) true))

(step test true :rule $unit_test :args (($is_evaluatable 1.0) true))

(step test true :rule $unit_test :args (($is_evaluatable 1/1) true))

(step test true :rule $unit_test :args (($is_evaluatable (* 1 2)) true))

(step test true :rule $unit_test :args (($is_evaluatable (* 1 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (* 1.0 2)) true))

(step test true :rule $unit_test :args (($is_evaluatable (* 1.0 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (* 1/1 2/1)) true))

(step test true :rule $unit_test :args (($is_evaluatable (+ 1 2)) true))

(step test true :rule $unit_test :args (($is_evaluatable (+ 1 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (+ 1.0 2)) true))

(step test true :rule $unit_test :args (($is_evaluatable (+ 1.0 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (+ 1/1 2/1)) true))

(step test true :rule $unit_test :args (($is_evaluatable (/ 1 2)) true))

(step test true :rule $unit_test :args (($is_evaluatable (/ 1.0 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (- 1 2)) true))

(step test true :rule $unit_test :args (($is_evaluatable (- 1.0 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (- 1)) true))

(step test true :rule $unit_test :args (($is_evaluatable (- 1.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (- (* 1.0 2.0))) true))

(step test true :rule $unit_test :args (($is_evaluatable (- (* 1.0 (+ 1.0 2.0)))) 
                                        true))

(step test true :rule $unit_test :args (($is_evaluatable (* (* 1.0 2.0) 2.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (* (* 1.0 2.0) (* 1.0 2.0))) 
                                        true))

(step test true :rule $unit_test :args (($is_evaluatable a) false))

(step test true :rule $unit_test :args (($is_evaluatable (f a)) false))

(step test true :rule $unit_test :args (($is_evaluatable (f 1)) false))

(step test true :rule $unit_test :args (($is_evaluatable (f (f 1))) false))

(step test true :rule $unit_test :args (($is_evaluatable (to_int 1.0)) true))

(step test true :rule $unit_test :args (($is_evaluatable (to_real 1)) true))

;---------------------------------
; $is_evaluatable_times_variable
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Real Real))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 1 a)) 

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 1.0 a)) 

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 1.0 (f 1.0))) 

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 1.0 (f (f b)))) 

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 
                                                       ($f_list_cons * 1.0 2.0)
                                                       (f (f b))))

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 1 2)
                                                       (f (f b))))

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons + 1.0 a)) 

                                        false))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons - 1.0 a)) 
                                        
                                        false))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 1.0 (+ 1 a))) 

                                        false))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 1.0 (+ 1 (f b)))) 

                                        false))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 
                                                       (to_int 1.0)
                                                       (f (f b))))

                                        true))

(step test true :rule $unit_test :args (($is_evaluatable_times_variable 
                                         ($f_list_cons * 
                                                       (to_real 1.0)
                                                       (f (f b))))

                                        true))

;---------------------------------
; $evaluatable_times_variable_get_variable
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Real Real))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
                                         ($f_list_cons * 1 a)) 

                                        a))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
                                         ($f_list_cons * 1.0 a)) 

                                        a))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
                                         ($f_list_cons * 1.0 (f 1.0))) 
                                        
                                        (f 1.0)))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
                                         ($f_list_cons * 1.0 (f (f b)))) 
                                        
                                        (f (f b))))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
                                         ($f_list_cons * (to_int 1.0) (f (f b)))) 
                                        
                                        (f (f b))))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
                                         ($f_list_cons * (to_real 1.0) (f (f b)))) 
                                        
                                        (f (f b))))

; Things that do not satisfy the pre.
;; (step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
;;                                          ($f_list_cons + 1.0 a)) 

;;                                         ($evaluatable_times_variable_get_variable 
;;                                          ($f_list_cons + 1.0 a))))

;; (step test true :rule $unit_test :args (($evaluatable_times_variable_get_variable 
;;                                          ($f_list_cons - 1.0 a)) 

;;                                         ($evaluatable_times_variable_get_variable 
;;                                          ($f_list_cons - 1.0 a))))

;---------------------------------
; $evaluatable_times_variable_get_evaluatable
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Real Real))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
                                         ($f_list_cons * 1 a)) 

                                        1))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
                                         ($f_list_cons * 1.0 a)) 

                                        1.0))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
                                         ($f_list_cons * 1.0 (f 1.0))) 
                                        
                                        1.0))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
                                         ($f_list_cons * 1.0 (f (f b)))) 
                                        
                                        1.0))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
                                         ($f_list_cons * (to_int 1.0) (f (f b)))) 
                                        
                                        (to_int 1.0)))

(step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
                                         ($f_list_cons * (to_real 1.0) (f (f b)))) 
                                        
                                        (to_real 1.0)))

; Things that do not satisfy the pre.
;; (step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
;;                                          ($f_list_cons + 1.0 a)) 

;;                                         ($evaluatable_times_variable_get_evaluatable 
;;                                          ($f_list_cons + 1.0 a))))

;; (step test true :rule $unit_test :args (($evaluatable_times_variable_get_evaluatable 
;;                                          ($f_list_cons - 1.0 a)) 

;;                                         ($evaluatable_times_variable_get_evaluatable 
;;                                          ($f_list_cons - 1.0 a))))

;---------------------------------
; $less_or_equal_literal
;---------------------------------

(step test true :rule $unit_test :args (($less_or_equal_literal 1 2) true))

(step test true :rule $unit_test :args (($less_or_equal_literal 1.0 2) true))

(step test true :rule $unit_test :args (($less_or_equal_literal 1.0 2/1) true))

(step test true :rule $unit_test :args (($less_or_equal_literal 1/1 2/1) true))

(step test true :rule $unit_test :args (($less_or_equal_literal 2/1 1/1) false))

(step test true :rule $unit_test :args (($less_or_equal_literal 2 1/1) false))

(step test true :rule $unit_test :args (($less_or_equal_literal 2.0 1/1) false))

; Things that do not satisfy the pre.
;; (step test true :rule $unit_test :args (($less_or_equal_literal (+ 1 1) 1) 

;;                                         ($less_or_equal_literal (+ 1 1) 1)))

;---------------------------------
; $less_or_equal_arith_terms
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Real Real))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 2) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 2 1) 
                                        
                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 2.0) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 2) 1) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 2) (* 2 3)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 3 2) (* 2 3)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 (* 1 1)) (* 2 3)) 
                                        
                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 (* 1 1)) 
                                                                    (* 1 (* 1 1))) 
                                        
                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 (+ 2 3)) 
                                        
                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 (* 2 3)) 
                                        
                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 a) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 b) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms a 1) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms b 1) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms 1 (f b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (f b) 1) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms a a) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms b b) 

                                        true))

; TODO: don't know if this will hold always
(step test true :rule $unit_test :args (($less_or_equal_arith_terms a b) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (f b) (f b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms b a) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms b (f b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (f b) b) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms a (f b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (f b) a) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 a) (* -1 a)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* -1 a) (* 1 a)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 a) (* 1 a)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 a) (* 1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* -1 a) (* 1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 2 a) (* 1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 2 a 2) (* 1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 2 a 2) b) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 3) (* 1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 b) (* 10 3)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 3 4) (* 1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 1 b) (* 10 3 4)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 3 4 8) (* -1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* -1 b) (* 10 3 4 8)) 
                                        
                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 3 4 8) (* b -1)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* b -1) (* 10 3 4 8)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 3 4 8) (* -2 b -1)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* -2 b -1) (* 10 3 4 8)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* 10 3 4 8) (* -2 -3 b -1)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (* -2 -3 b -1) 
                                                                    (* 10 3 4 8)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms ($f_list_cons * -1 b) 
                                                                    ($f_list_cons * 1 a)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms ($f_list_cons * 1 a) 
                                                                    ($f_list_cons * -1 b)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms ($f_list_cons * 1 b) 
                                                                    ($f_list_cons * 1 a)) 

                                        false))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms ($f_list_cons * -1 b) 
                                                                    ($f_list_cons * 1 a)) 

                                        false))
                                        ; Misc. 
(step test true :rule $unit_test :args (($less_or_equal_arith_terms (to_int 1) 
                                                                    (to_int 2)) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (to_int 3) 
                                                                    (to_int (* 1 2))) 

                                        true))

(step test true :rule $unit_test :args (($less_or_equal_arith_terms (to_int (* 1 2)) 
                                                                    (to_int 1)) 

                                        false))

;---------------------------------
; $get_lesser_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Int Real Real))

(step test true :rule $unit_test :args (($get_lesser_arith_term + ($f_list_cons + 1 2)) 

                                        1))

(step test true :rule $unit_test :args (($get_lesser_arith_term + ($f_list_cons + 1 0)) 

                                        0))

(step test true :rule $unit_test :args (($get_lesser_arith_term + ($f_list_cons + (* 1 1) 0)) 

                                        0))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + (* 3 4) (* 2 2))) 

                                        (* 2 2)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + (* 2 (* 2 2)) (* 2 2)))

                                        (* 2 2)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         * ($f_list_cons * a 0)) 
                                        
                                        0))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         * ($f_list_cons * 1 b)) 

                                        1))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         * ($f_list_cons * 
                                                         ($f_list_cons * 3 4) 
                                                         ($f_list_cons * 2 2)))

                                        2))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         * ($f_list_cons + (* 1 a) 1))

                                        ($f_list_cons + (* 1 a) 1)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + 
                                                         (* 1 a) 
                                                         (* 1 b)))

                                        (* 1 b)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + 
                                                         (* 1 a) 
                                                         ($f_list_cons + 
                                                                       (* -1 b)
                                                                       (* 1 b))))

                                        (* -1 b)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + 
                                                         (* 1 b) 
                                                         (* -1 b)))

                                        (* -1 b)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + 
                                                         ($f_list_cons * 1 a) 
                                                         ($f_list_cons +
                                                                       ($f_list_cons * 1 b)
                                                                       ($f_list_cons * -1 a))))

                                        ($f_list_cons * 1 b)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 a) 
                                                       ($f_list_cons 
                                                        +
                                                        ($f_list_cons * 1 b)
                                                        ($f_list_cons +
                                                                      ($f_list_cons * -1 a)
                                                                      ($f_list_cons * -1 b)))))

                                        ($f_list_cons * -1 b)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + ($f_list_cons + 
                                                         (* a 1) 
                                                         ($f_list_cons + 
                                                                       (* b 1)
                                                                       (* (f a b) 1))))

                                        (* b 1)))

(step test true :rule $unit_test :args (($get_lesser_arith_term 
                                         + 
                                         ($f_list_cons * (* a a) 1))

                                        ($f_list_cons * (* a a) 1)))

(step test true :rule $unit_test :args (($get_lesser_arith_term + (+ (+ (+ -2 a) 1) 
                                                                     (+ (+ b 3) (+ a b))))

                                        -2))

;---------------------------------
; $reorder_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Int Real Int))

; Addition
(step test true :rule $unit_test :args (($reorder_arith_term ($f_list_cons + 2 1))

                                        ($f_list_cons + 1 2)))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 3 
                                                       ($f_list_cons + 2 1)))

                                        ($f_list_cons + 1 ($f_list_cons + 2 3))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 4 ($f_list_cons + 1 4)))

                                        ($f_list_cons + 1 ($f_list_cons + 4 4))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 4 ($f_list_cons + a 4)))

                                        ($f_list_cons +
                                                      4
                                                      ($f_list_cons + 4 a))))

; Product
(step test true :rule $unit_test :args (($reorder_arith_term ($f_list_cons * 2 1))

                                        ($f_list_cons * 1 2)))

(step test true :rule $unit_test :args (($reorder_arith_term ($f_list_cons * 1 2))

                                        ($f_list_cons * 1 2)))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons * 2 ($f_list_cons * a 3)))

                                        ($f_list_cons * 
                                                      2
                                                      ($f_list_cons * 3 a))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons * a ($f_list_cons * a 3)))

                                        ($f_list_cons * 3 ($f_list_cons * a a))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons * a ($f_list_cons * b 3)))

                                        ($f_list_cons * 3 ($f_list_cons * a b))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons * b 
                                                       ($f_list_cons * 
                                                                     a 
                                                                     ($f_list_cons * a 3))))

                                        ($f_list_cons * 3 ($f_list_cons * 
                                                                        a 
                                                                        ($f_list_cons * a b)))))

; Addition and product
(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 2) 
                                                       ($f_list_cons + 3 4)))

                                        ($f_list_cons + 3 ($f_list_cons + 4 
                                                                        ($f_list_cons * 1 2)))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 2 1) 
                                                       ($f_list_cons + 3 4)))

                                        ($f_list_cons 
                                         + 3 ($f_list_cons + 4 ($f_list_cons * 1 2)))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + ($f_list_cons * 1 a) 1))

                                        ($f_list_cons + 1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + ($f_list_cons * a 1) 1))

                                        ($f_list_cons + 1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 a) 
                                                       ($f_list_cons * 1 b)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * 1 a) 
                                                      ($f_list_cons * 1 b))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 b) 
                                                       ($f_list_cons * 1 a)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * 1 a) 
                                                      ($f_list_cons * 1 b))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons 
                                          + 
                                          ($f_list_cons * 1 a) 
                                          ($f_list_cons + 
                                                        3
                                                        ($f_list_cons + 
                                                                      4
                                                                      ($f_list_cons * 4 b)))))

                                        ($f_list_cons 
                                         + 
                                         3
                                         ($f_list_cons + 4
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * 1 a)
                                                                     ($f_list_cons * 4 b))))))

; Terms with the same variables should appear together.
(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 b)
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * -200 a)
                                                                     ($f_list_cons * -1 b))))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -200 a)
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * -1 b)
                                                                    ($f_list_cons * 1 b)))))
(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons 
                                          +
                                          ($f_list_cons * -3 a)
                                          ($f_list_cons 
                                           +
                                           ($f_list_cons * 1 b)
                                           ($f_list_cons 
                                            + 
                                            ($f_list_cons * -49 a)
                                            ($f_list_cons * -1 b)))))

                                        ($f_list_cons 
                                         +
                                         ($f_list_cons * -49 a)
                                         ($f_list_cons 
                                          +
                                          ($f_list_cons * -3 a)
                                          ($f_list_cons 
                                           + 
                                           ($f_list_cons * -1 b)
                                           ($f_list_cons * 1 b))))))

(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons 
                                          + 
                                          ($f_list_cons 
                                           + 
                                           ($f_list_cons + 2 a) 1) 
                                          ($f_list_cons 
                                           + 
                                           ($f_list_cons + b 3) 
                                           ($f_list_cons + a b))))

                                        ($f_list_cons 
                                         + 
                                         1
                                         ($f_list_cons 
                                          +
                                          2
                                          ($f_list_cons 
                                           + 
                                           3
                                           ($f_list_cons 
                                            +
                                            a
                                            ($f_list_cons 
                                             + 
                                             a 
                                             ($f_list_cons + b b))))))))

; Reorder within to_int
(step test true :rule $unit_test :args (($reorder_arith_term 
                                         ($f_list_cons + 
                                                       (to_int ($f_list_cons + 3 2)) 
                                                       (to_int ($f_list_cons * 3 2))))

                                        ($f_list_cons + 
                                                      (to_int ($f_list_cons + 2 3)) 
                                                      (to_int ($f_list_cons * 2 3)))))

; Misc.
; No confusion between arith ops and uninterpreted functions.
(step test true :rule $unit_test :args (($reorder_arith_term (f 2 1.0))

                                        (f 2 1.0)))

(step test true :rule $unit_test :args (($reorder_arith_term (f (f 2 1.0) 3.0))

                                        (f (f 2 1.0) 3.0)))

(step test true :rule $unit_test :args (($reorder_arith_term
                                         ($f_list_cons 
                                          +
                                          ($f_list_cons * 1 a)
                                          ($f_list_cons +
                                                        ($f_list_cons * 1/1 b)
                                                        ($f_list_cons * -1/1
                                                                      ($f_list_cons 
                                                                       *
                                                                       -1
                                                                       ($f_list_cons * 1 a))))))
                                        ($f_list_cons 
                                         +
                                         ($f_list_cons * 1 a)
                                         ($f_list_cons +
                                                       ($f_list_cons * -1/1
                                                                     ($f_list_cons 
                                                                      * 
                                                                      -1
                                                                      ($f_list_cons * 1 a)))
                                                       ($f_list_cons * 1/1 b)))))

;------------------------------------
; $small_step_assoc_evaluatable_terms
;------------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)

; Additions
(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 1 2))

                                        ($f_list_cons + 1 2)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 2 3)))

                                        ($f_list_cons + ($f_list_cons + 1 2) 3)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     ($f_list_cons + 3 4))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 2) 
                                                      ($f_list_cons + 3 4))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 1 ($f_list_cons * 2 a)))

                                        ($f_list_cons + 1 ($f_list_cons * 2 a))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * 2 a)
                                                                     ($f_list_cons * 2 b))))

                                        ($f_list_cons + 
                                                      1 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * 2 a)
                                                                    ($f_list_cons * 2 b)))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     a)))

                                        ($f_list_cons + ($f_list_cons + 1 2) a)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     ($f_list_cons + 3 a))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 2) 
                                                      ($f_list_cons + 3 a))))

                                        ; Products
(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 1 2))

                                        ($f_list_cons * 1 2)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 1 
                                                       ($f_list_cons * 2 3)))

                                        ($f_list_cons * ($f_list_cons * 1 2) 3)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     ($f_list_cons * 3 4))))

                                        ($f_list_cons * 
                                                      ($f_list_cons * 1 2) 
                                                      ($f_list_cons * 3 4))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 1 ($f_list_cons * 2 a)))

                                        ($f_list_cons * ($f_list_cons * 1 2) a)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons * 
                                                      ($f_list_cons * 1 2)
                                                      ($f_list_cons * 3 a))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     a)))

                                        ($f_list_cons * ($f_list_cons * 1 2) a)))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons * 
                                                      ($f_list_cons * 1 2) 
                                                      ($f_list_cons * 3 a))))

                                        ; Additions and products.
(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons + 
                                                      1 
                                                      ($f_list_cons * 
                                                                    2 
                                                                    ($f_list_cons * 3 a)))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 a) 
                                                       ($f_list_cons *
                                                                     2 
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons + 
                                                      ($f_list_cons * 1 a) 
                                                      ($f_list_cons *
                                                                    2 
                                                                    ($f_list_cons * 3 a)))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + 3 a)
                                                                     a)))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 3)
                                                      ($f_list_cons + a a))))

(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons 
                                                        + 
                                                        2 
                                                        ($f_list_cons + 
                                                                      ($f_list_cons + 3 a)
                                                                      a))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 2)
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 3 a)
                                                                    a))))

; Association of uninterpreted terms.
(step test true :rule $unit_test :args (($small_step_assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 a)
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * 2 a) 
                                                                     ($f_list_cons * 3 b))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * 1 a)
                                                                    ($f_list_cons * 2 a))
                                                      ($f_list_cons * 3 b))))

;------------------------------------
; $assoc_evaluatable_terms
;------------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Int Real Real))

; Additions
(step test true :rule $unit_test :args (($assoc_evaluatable_terms ($f_list_cons + 1 2))

                                        ($f_list_cons + 1 2)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 2 3)))

                                        ($f_list_cons + ($f_list_cons + 1 2) 3)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     ($f_list_cons + 3 4))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 1 2) 
                                                                    3)
                                                      4)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 ($f_list_cons * 2 a)))

                                        ($f_list_cons + 1 ($f_list_cons * 2 a))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * 2 a)
                                                                     ($f_list_cons * 2 b))))

                                        ($f_list_cons + 
                                                      1 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * 2 a)
                                                                    ($f_list_cons * 2 b)))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     a)))

                                        ($f_list_cons + ($f_list_cons + 1 2) a)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     ($f_list_cons + 3 a))))

                                        ($f_list_cons +
                                                      ($f_list_cons + ($f_list_cons + 1 2) 3)
                                                      a)))

                                        ; Products
(step test true :rule $unit_test :args (($assoc_evaluatable_terms ($f_list_cons * 1 2))

                                        ($f_list_cons * 1 2)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 2 3)))

                                        ($f_list_cons * ($f_list_cons * 1 2) 3)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     ($f_list_cons * 3 4))))

                                        ($f_list_cons *
                                                      ($f_list_cons * ($f_list_cons * 1 2) 3)
                                                      4)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons * 1 ($f_list_cons * 2 a)))

                                        ($f_list_cons * ($f_list_cons * 1 2) a)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons * 
                                                                     2
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons * 
                                                      ($f_list_cons * 
                                                                    ($f_list_cons * 1 2)
                                                                    3)
                                                      a)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons * 1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     a)))

                                        ($f_list_cons * ($f_list_cons * 1 2) a)))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons * 1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons * 
                                                      ($f_list_cons * ($f_list_cons * 1 2) 3)
                                                      a)))

                                        ; Addition and products.
(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons * 
                                                                     2 
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons + 1 
                                                      ($f_list_cons *
                                                                    ($f_list_cons * 2 3) 
                                                                    a))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1 a) 
                                                       ($f_list_cons *
                                                                     2 
                                                                     ($f_list_cons * 3 a))))

                                        ($f_list_cons + 
                                                      ($f_list_cons * 1 a) 
                                                      ($f_list_cons * 
                                                                    ($f_list_cons * 2 3) 
                                                                    a))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons 
                                          + 
                                          1
                                          ($f_list_cons 
                                           + 
                                           2
                                           ($f_list_cons 
                                            + 
                                            3
                                            ($f_list_cons 
                                             * 
                                             3 
                                             ($f_list_cons * 2 a))))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + ($f_list_cons + 1 2) 3)
                                                      ($f_list_cons * ($f_list_cons * 3 2) a))))

; Association of uninterpreted terms
(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 1 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + 3 a)
                                                                     a)))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 3)
                                                      ($f_list_cons + a a))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons 
                                          + 
                                          1 
                                          ($f_list_cons + 
                                                        2 
                                                        ($f_list_cons + 
                                                                      ($f_list_cons + 3 a)
                                                                      a))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 1 2) 3)
                                                      ($f_list_cons + a a))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons + 
                                                       1 
                                                       ($f_list_cons + 
                                                                     2 
                                                                     ($f_list_cons + 
                                                                                   ($f_list_cons + 3 a)
                                                                                   a))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 1 2) 3)
                                                      ($f_list_cons + a a))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons 
                                          + 
                                          1 
                                          ($f_list_cons 
                                           + 
                                           2 
                                           ($f_list_cons + 
                                                         ($f_list_cons * 1 a)
                                                         ($f_list_cons * 2 a)))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 2)
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * 1 a)
                                                                    ($f_list_cons * 2 a)))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons 
                                          + 
                                          1 
                                          ($f_list_cons 
                                           + 
                                           2 
                                           ($f_list_cons + 
                                                         ($f_list_cons * 1 a)
                                                         ($f_list_cons + 
                                                                       ($f_list_cons * 2 a)
                                                                       ($f_list_cons * 3 b))))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 2)
                                                      ($f_list_cons 
                                                       + 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * 1 a)
                                                                     ($f_list_cons * 2 a))
                                                       ($f_list_cons * 3 b)))))

(step test true :rule $unit_test :args (($assoc_evaluatable_terms 
                                         ($f_list_cons 
                                          + 
                                          1 
                                          ($f_list_cons 
                                           + 
                                           2 
                                           ($f_list_cons + 
                                                         ($f_list_cons * 1 a)
                                                         ($f_list_cons 
                                                          + 
                                                          ($f_list_cons * 2 a)
                                                          ($f_list_cons 
                                                           + 
                                                           ($f_list_cons * 3 b)
                                                           ($f_list_cons 
                                                            +
                                                            ($f_list_cons * 4 b)
                                                            ($f_list_cons * 5 (f a b)))))))))

                                        ($f_list_cons 
                                         + 
                                         ($f_list_cons + 1 2)
                                         ($f_list_cons + 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons * 1 a)
                                                                     ($f_list_cons * 2 a))
                                                       ($f_list_cons 
                                                        + 
                                                        ($f_list_cons + 
                                                                      ($f_list_cons * 3 b)
                                                                      ($f_list_cons * 4 b))
                                                        ($f_list_cons * 5 (f a b)))))))

;---------------------------------
; $build_proper_monomials
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Int Int))

; Single term
(step test true :rule $unit_test :args (($build_proper_monomials a)

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($build_proper_monomials b)

                                        ($f_list_cons * 1/1 b)))

(step test true :rule $unit_test :args (($build_proper_monomials (f a))

                                        ($f_list_cons * 1 (f a))))

                                        ; Additions
(step test true :rule $unit_test :args (($build_proper_monomials ($f_list_cons + 1 a))

                                        ($f_list_cons + 1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($build_proper_monomials ($f_list_cons + 1 b))

                                        ($f_list_cons + 1 ($f_list_cons * 1/1 b))))

(step test true :rule $unit_test :args (($build_proper_monomials ($f_list_cons + a 1))

                                        ($f_list_cons + ($f_list_cons * 1 a) 1)))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + 1 ($f_list_cons + 2 a)))

                                        ($f_list_cons + 
                                                      1 
                                                      ($f_list_cons + 2 ($f_list_cons * 1 a)))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + 1 ($f_list_cons + a 2)))

                                        ($f_list_cons + 1 
                                                      ($f_list_cons + ($f_list_cons * 1 a) 2))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + 1 ($f_list_cons + b 2)))

                                        ($f_list_cons 
                                         + 
                                         1 
                                         ($f_list_cons + ($f_list_cons * 1/1 b) 2))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + a ($f_list_cons + 1 2)))

                                        ($f_list_cons 
                                         + 
                                         ($f_list_cons * 1 a) 
                                         ($f_list_cons + 1 2))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + b ($f_list_cons + 1 2)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * 1/1 b) 
                                                      ($f_list_cons + 1 2))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + a ($f_list_cons * 1 2)))

                                        ($f_list_cons 
                                         + 
                                         ($f_list_cons * 1 a) 
                                         ($f_list_cons * 1 2))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + 2 3) 
                                                                     a) 
                                                       4))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 2 3)
                                                                    ($f_list_cons * 1 a)) 
                                                      4)))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + 2 3) 
                                                                     b) 
                                                       4))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 2 3)
                                                                    ($f_list_cons * 1/1 b)) 
                                                      4)))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons + 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + b 3) 
                                                                     a) 
                                                       4))

                                        ($f_list_cons 
                                         + 
                                         ($f_list_cons 
                                          + 
                                          ($f_list_cons 
                                           + 
                                           ($f_list_cons * 1/1 b) 
                                           3)
                                          ($f_list_cons * 1 a)) 
                                         4)))

                                        ; Subtraction
(step test true :rule $unit_test :args (($build_proper_monomials (- 1 a))

                                        (- 1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($build_proper_monomials (- 1 b))

                                        (- 1 ($f_list_cons * 1/1 b))))

(step test true :rule $unit_test :args (($build_proper_monomials (- 1 (- 2 a)))

                                        (- 1 (- 2 ($f_list_cons * 1 a)))))

(step test true :rule $unit_test :args (($build_proper_monomials (- 1 (- a 2)))

                                        (- 1 (- ($f_list_cons * 1 a) 2))))

(step test true :rule $unit_test :args (($build_proper_monomials (- 1 (- b 2)))

                                        (- 1 (- ($f_list_cons * 1/1 b) 2))))

(step test true :rule $unit_test :args (($build_proper_monomials (- a (- 1 2)))

                                        (- ($f_list_cons * 1 a) (- 1 2))))

(step test true :rule $unit_test :args (($build_proper_monomials (- b (- 1 2)))

                                        (- ($f_list_cons * 1/1 b) (- 1 2))))

(step test true :rule $unit_test :args (($build_proper_monomials (- (f a) (- 1 2)))

                                        (- ($f_list_cons * 1 (f a)) (- 1 2))))

                                        ; Negative
(step test true :rule $unit_test :args (($build_proper_monomials (- 1))

                                        (- 1)))

(step test true :rule $unit_test :args (($build_proper_monomials (- a))

                                        (- ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($build_proper_monomials (- ($f_list_cons + a 1)))

                                        (- ($f_list_cons + ($f_list_cons * 1 a) 1))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         (- ($f_list_cons + 1 ($f_list_cons + a 2))))

                                        (- ($f_list_cons + 
                                                         1 
                                                         ($f_list_cons + 
                                                                       ($f_list_cons * 1 a) 2)))))

                                        ; Product (shouldn't change)
(step test true :rule $unit_test :args (($build_proper_monomials ($f_list_cons * 1 a))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($build_proper_monomials ($f_list_cons * 1 (f a)))

                                        ($f_list_cons * 1 (f a))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons * 1 ($f_list_cons * 2 (f a))))

                                        ($f_list_cons * 1 ($f_list_cons * 2 (f a)))))

(step test true :rule $unit_test :args (($build_proper_monomials 
                                         ($f_list_cons * a ($f_list_cons * 2 1)))

                                        ($f_list_cons * a ($f_list_cons * 2 1))))

                                        ; Working within to_int
(step test true :rule $unit_test :args (($build_proper_monomials (to_int a))

                                        (to_int ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($build_proper_monomials (to_int b))

                                        (to_int ($f_list_cons * 1/1 b))))

(step test true :rule $unit_test :args (($build_proper_monomials (to_int (+ 1 a)))

                                        (to_int (+ 1 ($f_list_cons * 1 a)))))

(step test true :rule $unit_test :args (($build_proper_monomials (to_int (+ 1 b)))

                                        (to_int (+ 1 ($f_list_cons * 1/1 b)))))

(step test true :rule $unit_test :args (($build_proper_monomials (to_int (* 1 a)))

                                        (to_int (* 1 a))))

(step test true :rule $unit_test :args (($build_proper_monomials (to_int (* 1 a)))

                                        (to_int (* 1 a))))

                                        ; Misc.
(step test true :rule $unit_test :args (($build_proper_monomials (- (- 1 a) 
                                                                    (- (- b a) 2)))

                                        (- (- 1 ($f_list_cons * 1 a)) 
                                           (- (- ($f_list_cons * 1/1 b) 
                                                 ($f_list_cons * 1 a)) 2))))

;---------------------------------
; $small_step_reduction_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const f (-> Real Real))

; Case (+ 0 rhs) = rhs
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0.0 1))

                                        1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0.0 (+ 1 1)))

                                        (+ 1 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0 1))

                                        1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0 (+ 1 1)))

                                        (+ 1 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0/1 1))

                                        1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0/1 (+ 1 1)))

                                        (+ 1 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0 ($f_list_cons * 1/1 a)))

                                        ($f_list_cons * 1/1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0.0 ($f_list_cons * 1/1 a)))

                                        ($f_list_cons * 1/1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 0/1 ($f_list_cons * 1/1 a)))

                                        ($f_list_cons * 1/1 a)))

; Uninterpreted terms have a context-dependent semantics, they
; shouldn't be reduced by this relation.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term a)

                                        a))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term (f b))

                                        (f b)))

; Case (+ lhs 0) = lhs
; NOTE: this case is given semantics directly through eo::add,
; previous conversion to rational. of operands.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 1 0.0))

                                        1/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 1 0))

                                        1/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 1 0/1))

                                        1/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 
                                                       (+ 2 3) 
                                                       0.0))
                                        
                                        (+ 2 3)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 
                                                       (+ 2 3) 0))

                                        (+ 2 3)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + ($f_list_cons * 2/1 a) 0))

                                        ($f_list_cons * 2/1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + ($f_list_cons * 4/1 a) 0/1))

                                        ($f_list_cons * 4/1 a)))

; Case + lhs rhs when they are numeric literals.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 1 2))

                                        3/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons + 1.0 2.0))

                                        3/1))

; Case (+ (* a x) (* b x)) = (* (+ a b) x)
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons +
                                                       ($f_list_cons * 3 a)
                                                       ($f_list_cons * 4 a)))
                                        
                                        ($f_list_cons * ($f_list_cons + 3 4) a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons +
                                                       ($f_list_cons * ($f_list_cons * 3 4) a)
                                                       ($f_list_cons * 4 a)))

                                        ($f_list_cons * ($f_list_cons + ($f_list_cons * 3 4) 4) a)))

; Case (* 0 rhs) = 0
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0.0 1))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0.0 (+ 1 1)))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0 1))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0 (+ 1 1)))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0 (+ 1 1.0)))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0/1 1))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0/1 (+ 1 1)))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0 a))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0.0 a))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0/1 a))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0/1 b))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 0 b))

                                        0/1))

; Case (* lhs 0) = lhs
; NOTE: this case is given semantics directly through eo::add,
; previous conversion to rational. of operands.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1 0/1))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1 0))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 
                                                       0.0))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 0))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * a 0))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * b 0))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * a 0/1))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * b 0/1))

                                        0/1))

; Case (* 1 rhs) = rhs
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1.0 5))

                                        5))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1.0 (+ 1 1)))

                                        (+ 1 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1 3.0))

                                        3.0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1 (+ 1 1)))

                                        (+ 1 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1/1 5))

                                        5))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1/1 (+ 1 1)))

                                        (+ 1 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1 a))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1 b))

                                        ($f_list_cons * 1/1 b)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1.0 a))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1/1 a))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 1/1 b))

                                        ($f_list_cons * 1/1 b)))

; Case (* lhs 1) = lhs
; NOTE: this case is given semantics directly through eo::mul,
; previous conversion of operands to rational.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 2 1/1))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 3 1))

                                        3/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 
                                                       1.0))

                                        (+ 2 3)))

; Case (* -1 rhs) = rhs
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1.0 5))

                                        -5/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1.0 (+ 1 1)))

                                        ($f_list_cons * -1 (+ 1 1))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1 3.0))

                                        -3/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1 (+ 1 1)))

                                        ($f_list_cons * -1 (+ 1 1))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1/1 5))

                                        -5/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1/1 (+ 1 1)))

                                        ($f_list_cons * -1 (+ 1 1))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1 a))

                                        ($f_list_cons * -1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1 b))

                                        ($f_list_cons * -1/1 b)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1.0 a))

                                        ($f_list_cons * -1 a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * -1 a))

                                        ($f_list_cons * -1 a)))

; Case (* lhs -1) = lhs
; NOTE: this case is given semantics directly through eo::mul,
; previous conversion of operands to rational.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 2 -1/1))

                                        -2/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 3 -1))

                                        -3/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 
                                                       -1.0))

                                        ($f_list_cons * -1 (+ 2 3))))

; Case * lhs rhs when they are numeric literals.
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 3 2))

                                        6/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 3.0 2.0))

                                        6/1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         ($f_list_cons * 3/1 2/1))

                                        6/1))

; to_int
(step test true :rule $unit_test :args (($small_step_reduction_arith_term (to_int 0.0))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term (to_int 0.1))

                                        0))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term (to_int 1.1))

                                        1))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + 1.1 1)))

                                        ($f_list_cons + (to_int 1.1) 1)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + 1.1 a)))
                                        ($f_list_cons + (to_int 1.1) a)))

                                        ; NOTE: check this case...
(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + a 1.1)))
                                        ($f_list_cons + a (to_int 1.1))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + b 1.1)))
                                        (to_int ($f_list_cons + b 1.1))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + b a)))
                                        ($f_list_cons + (to_int b) a)))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + a b)))
                                        ($f_list_cons + a (to_int b))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + 5/1 1.1)))
                                        ($f_list_cons + 5/1 (to_int 1.1))))

(step test true :rule $unit_test :args (($small_step_reduction_arith_term 
                                         (to_int ($f_list_cons + 1.1 5/1)))
                                        ($f_list_cons + (to_int 1.1) 5/1)))

;---------------------------------
; $small_step_evaluator_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)

; Case (+ 0 rhs) = rhs
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 0.0 1))

                                        1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 0.0 (+ 1 1)))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 0 1))

                                        1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 0 (+ 1 1)))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 0/1 1))

                                        1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 0/1 (+ 1 1)))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       0 
                                                       ($f_list_cons * 1/1 a)))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       0.0 
                                                       ($f_list_cons * 1/1 a)))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       0/1 
                                                       ($f_list_cons * 1/1 a)))

                                        ($f_list_cons * 1 a)))

; Case (+ lhs 0) = lhs
; NOTE: this case is given semantics directly through eo::add,
; previous conversion to rational. of operands.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 1 0.0))

                                        1/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 1 0))

                                        1/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 1 0/1))

                                        1/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       (+ 2 3) 
                                                       0.0))

                                        5/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       (+ 2 3) 0))

                                        5/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1/1 a) 
                                                       0))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 1/1 a) 
                                                       0/1))

                                        ($f_list_cons * 1 a)))

; Case + lhs rhs when they are numeric literals.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 1 2))

                                        3/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 1.0 2.0))

                                        3/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       3.0 
                                                       ($f_list_cons * 4.0 3.0)))

                                        15/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 4.0 3.0) 
                                                       ($f_list_cons * 4.0 3.0)))

                                        24/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 4.0 3.0) 
                                                       ($f_list_cons * 
                                                                     ($f_list_cons * 4.0 3.0) 3.0)))

                                        48/1))

; Case (+ (* a x) (* b x)) = (* (+ a b) x)
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons +
                                                       ($f_list_cons * 3 a)
                                                       ($f_list_cons * 4 a)))

                                        ($f_list_cons * 7/1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons +
                                                       ($f_list_cons * ($f_list_cons * 3 4) a)
                                                       ($f_list_cons * 4 a)))

                                        ($f_list_cons * 16/1 a)))

; Case (* 0 rhs) = 0
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0.0 1))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0.0 (+ 1 1)))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0 1))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0 (+ 1 1)))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0/1 1))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0/1 (+ 1 1)))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0 a))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0.0 a))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 0/1 a))

                                        0))

; Case (* lhs 0) = lhs
; NOTE: this case is given semantics directly through eo::add,
; previous conversion to rational. of operands.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1 0/1))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1 0))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 
                                                       0.0))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 0))

                                        0/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * a 0))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * a 0/1))

                                        0))

                                        ; Case (* 1 rhs) = rhs
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1.0 5))

                                        5))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1.0 (+ 1 1)))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1 3.0))

                                        3.0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1 (+ 1 1)))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1/1 5))

                                        5))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1/1 (+ 1 1)))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1 a))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1.0 a))

                                        ($f_list_cons * 1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 1/1 a))

                                        ($f_list_cons * 1 a)))

; Case (* lhs 1) = lhs
; NOTE: this case is given semantics directly through eo::mul,
; previous conversion of operands to rational.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 2 1/1))

                                        2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 3 1))

                                        3/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 
                                                       1.0))

                                        5/1))

; Case (* -1 rhs) = rhs
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1.0 5))

                                        -5/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1.0 (+ 1 1)))

                                        -2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1 3.0))

                                        -3/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1 (+ 1 1)))

                                        -2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1/1 5))

                                        -5/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1/1 (+ 1 1)))

                                        -2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1 a))

                                        ($f_list_cons * -1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1.0 a))

                                        ($f_list_cons * -1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * -1/1 a))

                                        ($f_list_cons * -1 a)))

; Case (* lhs -1) = lhs
; NOTE: this case is given semantics directly through eo::mul,
; previous conversion of operands to rational.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 2 -1/1))

                                        -2/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 3 -1))

                                        -3/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 
                                                       (+ 2 3) 
                                                       -1.0))

                                        -5/1))

; Case * lhs rhs when they are numeric literals.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 3 2))

                                        6/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 3.0 2.0))

                                        6/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons * 3/1 2/1))

                                        6/1))
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons *
                                                       3.0
                                                       ($f_list_cons * 4.0 3.0)))

                                        36/1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons *
                                                       ($f_list_cons * 4.0 3.0)
                                                       3.0))

                                        36/1))

; to_int
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term (to_int 0.0))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term (to_int 0.1))

                                        0))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term (to_int 1.1))

                                        1))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int (+ 1.1 1)))

                                        2))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + 1.1 a)))
                                        ($f_list_cons + 1 a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + a 1.1)))
                                        ($f_list_cons + a 1)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + b 1.1)))
                                        (to_int ($f_list_cons + b 1.1))))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + b a)))
                                        ($f_list_cons + (to_int b) a)))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + a b)))
                                        ($f_list_cons + a (to_int b))))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons * a b)))
                                        (to_int ($f_list_cons * a b))))

; NOTE: check this case
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons * 1 b)))
                                        (to_int ($f_list_cons * 1/1 b))))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + 5/1 b)))
                                        ($f_list_cons + 5/1 (to_int b))))

(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         (to_int ($f_list_cons + b 5/1)))
                                        ($f_list_cons + (to_int b) 5/1)))

; Misc.
(step test true :rule $unit_test :args (($small_step_evaluator_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * 
                                                                     -1 
                                                                     ($f_list_cons * 1 b))

                                                       ($f_list_cons * 
                                                                     -1 
                                                                     ($f_list_cons * 1 a))))
                                        ($f_list_cons + 
                                                      ($f_list_cons * 
                                                                    -1/1 
                                                                    ($f_list_cons * 1/1 b))
                                                      ($f_list_cons * 
                                                                    -1 
                                                                    ($f_list_cons * 1 a)))))


;---------------------------------
; $small_step_normalize_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)

; Getting rid of leading unary "-".
(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons + 2 4)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons * -1 4))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons + 
                                                          2 
                                                          ($f_list_cons + 3 4))))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons * -1 ($f_list_cons + 3 4)))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons + 2 a)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons * -1 a))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons + 2.0 a)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1/1 2.0)
                                                      ($f_list_cons * -1 a))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons + 
                                                          ($f_list_cons + 2 a) 
                                                          4)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 ($f_list_cons + 2 a))
                                                      ($f_list_cons * -1 4))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons * 2 4)))

                                        ($f_list_cons *
                                                      ($f_list_cons * -1 2)
                                                      4)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons *
                                                          2 
                                                          ($f_list_cons + 3 4))))

                                        ($f_list_cons *
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons + 3 4))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons * 2 a)))

                                        ($f_list_cons *
                                                      ($f_list_cons * -1 2)
                                                      a)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- ($f_list_cons *
                                                          ($f_list_cons + 2 a) 
                                                          4)))

                                        ($f_list_cons *
                                                      ($f_list_cons 
                                                       * 
                                                       -1 
                                                       ($f_list_cons + 2 a))
                                                      4)))

                                        ; Case - (- lhs) = lhs
(step test true :rule $unit_test :args (($small_step_normalize_arith_term (- (- 4)))

                                        4))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term (- (- (+ 1 2))))

                                        (+ 1 2)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (- (+ 1 (+ 2 3)))))

                                        (+ 1 (+ 2 3))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (- (+ 1 a))))

                                        (+ 1 a)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (- (* 1 2))))

                                        (* 1 2)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (- (* 1 (* 2 3)))))

                                        (* 1 (* 2 3))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (- (* 1 a))))

                                        (* 1 a)))

                                        ; Getting rid of subtractions.
(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- 1 2))

                                        ($f_list_cons + 
                                                      1
                                                      ($f_list_cons * -1 2))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (+ 1 2) 3))

                                        ($f_list_cons + 
                                                      (+ 1 2)
                                                      ($f_list_cons * -1 3))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (+ 1 2) (+ 3 4)))

                                        ($f_list_cons + 
                                                      (+ 1 2)
                                                      ($f_list_cons * -1 (+ 3 4)))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         (- (+ 1 2) (- (+ 3 4) (+ 5 6))))

                                        ($f_list_cons + 
                                                      (+ 1 2)
                                                      ($f_list_cons * -1 (- (+ 3 4) (+ 5 6))))))

; Distributivity 
(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons + 2 3)))

                                        ($f_list_cons +
                                                      ($f_list_cons * 1 2) 
                                                      ($f_list_cons * 1 3))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3) 
                                                       ($f_list_cons + 4 5)))

                                        ($f_list_cons +
                                                      ($f_list_cons * ($f_list_cons + 2 3) 4) 
                                                      ($f_list_cons * ($f_list_cons + 2 3) 5))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       a
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + 4 5)
                                                                     ($f_list_cons + 6 7))))

                                        ($f_list_cons +
                                                      ($f_list_cons * a ($f_list_cons + 4 5)) 
                                                      ($f_list_cons * a ($f_list_cons + 6 7)))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * -1/1 ($f_list_cons + 2 a)))

                                        ($f_list_cons +
                                                      ($f_list_cons * -1/1 2 )
                                                      ($f_list_cons * -1/1 a))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons *
                                                       4
                                                       ($f_list_cons +
                                                                     ($f_list_cons * -1/1 2 )
                                                                     ($f_list_cons * -1/1 a))))

                                        ($f_list_cons +
                                                      ($f_list_cons 
                                                       * 
                                                       4 
                                                       ($f_list_cons * -1/1 2))

                                                      ($f_list_cons 
                                                       * 
                                                       4 
                                                       ($f_list_cons * -1/1 a)))))

; Commutativity to exploit distributivity on a later step.
(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3)
                                                       1))

                                        ($f_list_cons * 
                                                      1
                                                      ($f_list_cons + 2 3))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3)
                                                       ($f_list_cons * 2 3)))

                                        ($f_list_cons * 
                                                      ($f_list_cons * 2 3)
                                                      ($f_list_cons + 2 3))))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3)
                                                       a))

                                        ($f_list_cons * 
                                                      ($f_list_cons + 2 3)
                                                      a)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + ($f_list_cons * 2 3) 4)
                                                       a))

                                        ($f_list_cons * 
                                                      ($f_list_cons + ($f_list_cons * 2 3) 4)
                                                      a)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons *
                                                       ($f_list_cons +
                                                                     ($f_list_cons * -1/1 2 )
                                                                     ($f_list_cons * -1/1 a))
                                                       4))

                                        ($f_list_cons *
                                                      4
                                                      ($f_list_cons +
                                                                    ($f_list_cons * -1/1 2 )
                                                                    ($f_list_cons * -1/1 a)))))

                                        ; Misc.
(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons * -1/1 a))

                                        ($f_list_cons * -1/1 a)))

(step test true :rule $unit_test :args (($small_step_normalize_arith_term 
                                         ($f_list_cons + 
                                                       ($f_list_cons * -1/1 2)
                                                       ($f_list_cons * -1/1 a)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1/1 2)
                                                      ($f_list_cons * -1/1 a))))

;---------------------------------
; $normalize_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)

; Getting rid of leading unary "-".
(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 2 4)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons * -1 4))))


(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 
                                                          2 
                                                          ($f_list_cons + 3 4))))

                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons +
                                                                    ($f_list_cons * -1 3)
                                                                    ($f_list_cons * -1 4)))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 
                                                          ($f_list_cons + 3 4) 
                                                          ($f_list_cons + 5 6))))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * -1 3)
                                                                    ($f_list_cons * -1 4))
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * -1 5)
                                                                    ($f_list_cons * -1 6)))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 2 ($f_list_cons * 1 a))))
                                        
                                        ($f_list_cons + 
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons * 
                                                                    -1
                                                                    ($f_list_cons * 1 a)))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 
                                                          ($f_list_cons + 2 ($f_list_cons * 1 a))
                                                          4)))

                                        ($f_list_cons +
                                                      ($f_list_cons +
                                                                    ($f_list_cons * -1 2)
                                                                    ($f_list_cons * -1 ($f_list_cons * 1 a)))
                                                      ($f_list_cons * -1 4))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons * 2 4)))

                                        ($f_list_cons *
                                                      ($f_list_cons * -1 2)
                                                      4)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons *
                                                          2 
                                                          ($f_list_cons + 3 4))))

                                        ($f_list_cons +
                                                      ($f_list_cons * 
                                                                    ($f_list_cons * -1 2)
                                                                    3)
                                                      ($f_list_cons *
                                                                    ($f_list_cons * -1 2)
                                                                    4))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons * 2 ($f_list_cons * 1 a))))

                                        ($f_list_cons *
                                                      ($f_list_cons * -1 2)
                                                      ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons *
                                                          ($f_list_cons + 
                                                                        2 
                                                                        ($f_list_cons * 1 a)) 
                                                          4)))

                                        ($f_list_cons +
                                                      ($f_list_cons * 4 ($f_list_cons * -1 2))
                                                      ($f_list_cons 
                                                       * 
                                                       4 
                                                       ($f_list_cons * -1
                                                                     ($f_list_cons * 1 a))))))

; Case - (- lhs) = lhs
(step test true :rule $unit_test :args (($normalize_arith_term (- (- 4)))

                                        4))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- ($f_list_cons + 1 2))))

                                        ($f_list_cons + 1 2)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- ($f_list_cons + 1 ($f_list_cons + 2 3)))))

                                        ($f_list_cons + 
                                                      1
                                                      ($f_list_cons + 2 3))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- ($f_list_cons + 1 ($f_list_cons * 1 a)))))

                                        ($f_list_cons + 1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- ($f_list_cons * 1 2))))

                                        ($f_list_cons * 1 2)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- ($f_list_cons * 1 ($f_list_cons * 2 3)))))

                                        ($f_list_cons * 
                                                      1
                                                      ($f_list_cons * 2 3))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- ($f_list_cons * 1 ($f_list_cons * 1 a)))))

                                        ($f_list_cons * 1 ($f_list_cons * 1 a))))

                                        ; Getting rid of subtractions.
(step test true :rule $unit_test :args (($normalize_arith_term (- 1 2))

                                        ($f_list_cons + 
                                                      1
                                                      ($f_list_cons * -1 2))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 1 2) 3))

                                        ($f_list_cons + 
                                                      ($f_list_cons + 1 2)
                                                      ($f_list_cons * -1 3))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- ($f_list_cons + 1 2) 
                                            ($f_list_cons + 3 4)))

                                        ($f_list_cons +
                                                      ($f_list_cons + 1 2)
                                                      ($f_list_cons +
                                                                    ($f_list_cons * -1 3)
                                                                    ($f_list_cons * -1 4)))))

                                        ; Distributivity.
(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       1 
                                                       ($f_list_cons + 2 3)))

                                        ($f_list_cons +
                                                      ($f_list_cons * 1 2) 
                                                      ($f_list_cons * 1 3))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons +
                                                       ($f_list_cons *
                                                                     4
                                                                     ($f_list_cons + 2 3))
                                                       ($f_list_cons *
                                                                     5
                                                                     ($f_list_cons + 2 3))))

                                        ($f_list_cons +
                                                      ($f_list_cons +
                                                                    ($f_list_cons * 4 2)
                                                                    ($f_list_cons * 4 3))
                                                      ($f_list_cons +
                                                                    ($f_list_cons * 5 2)
                                                                    ($f_list_cons * 5 3)))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3) 
                                                       ($f_list_cons + 4 5)))

                                        ($f_list_cons +
                                                      ($f_list_cons +
                                                                    ($f_list_cons * 4 2)
                                                                    ($f_list_cons * 4 3))
                                                      ($f_list_cons +
                                                                    ($f_list_cons * 5 2)
                                                                    ($f_list_cons * 5 3)))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 4 5)
                                                       a))

                                        ($f_list_cons * 
                                                      ($f_list_cons + 4 5)
                                                      a)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 
                                                                     ($f_list_cons + 4 5)
                                                                     ($f_list_cons + 6 7))
                                                       a))

                                        ($f_list_cons * 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons + 4 5)
                                                                    ($f_list_cons + 6 7))
                                                      a)))

; Commutativity to exploit distributivity on a later step.
(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3)
                                                       1))

                                        ($f_list_cons +
                                                      ($f_list_cons * 1 2)
                                                      ($f_list_cons * 1 3))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3)
                                                       ($f_list_cons * 4 5)))

                                        ($f_list_cons + 
                                                      ($f_list_cons * ($f_list_cons * 4 5) 2)
                                                      ($f_list_cons * ($f_list_cons * 4 5) 3))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + 2 3)
                                                       a))

                                        ($f_list_cons * 
                                                      ($f_list_cons + 2 3)
                                                      a)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         ($f_list_cons * 
                                                       ($f_list_cons + ($f_list_cons * 2 3) 4)
                                                       a))

                                        ($f_list_cons * 
                                                      ($f_list_cons + ($f_list_cons * 2 3) 4)
                                                      a)))

; Normalizing within to_int
; Getting rid early of to_int applied to integer expressions
(step test true :rule $unit_test :args (($normalize_arith_term (to_int 1))
                                        
                                        1))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (to_int ($f_list_cons + 1 2)))
                                        
                                        ($f_list_cons + 1 2)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (to_int ($f_list_cons + 
                                                               1 
                                                               ($f_list_cons * 2 3))))
                                        
                                        ($f_list_cons + 1 ($f_list_cons * 2 3))))

                                        ; Normalizing within to_int
(step test true :rule $unit_test :args (($normalize_arith_term (to_int 1.0))
                                        
                                        (to_int 1.0)))

(step test true :rule $unit_test :args (($normalize_arith_term (to_int (+ 1.0 2)))
                                        
                                        (to_int (+ 1.0 2))))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (to_int (+ 1 (+ 2.0 3.0))))
                                        
                                        (to_int (+ 1 (+ 2.0 3.0)))))

(step test true :rule $unit_test :args (($normalize_arith_term (to_int (- (- 1))))
                                        
                                        1))

(step test true :rule $unit_test :args (($normalize_arith_term (to_int (- (- 1.0))))
                                        
                                        (to_int 1.0)))

                                        ; Misc.
(step test true :rule $unit_test :args (($normalize_arith_term -1/1)

                                        -1/1))

(step test true :rule $unit_test :args (($normalize_arith_term ($f_list_cons * -1/1 a))

                                        ($f_list_cons * -1/1 a)))

(step test true :rule $unit_test :args (($normalize_arith_term 
                                         (- (- 1 ($f_list_cons * 1 a)) 
                                            (- (- ($f_list_cons * 1/1 b) 
                                                  ($f_list_cons * 1 a)) 2)))

                                        ($f_list_cons 
                                         + 

                                         ($f_list_cons 
                                          + 
                                          1 ($f_list_cons 
                                             * 
                                             -1 
                                             ($f_list_cons * 1 a)))

                                         ($f_list_cons 
                                          + 
                                          ($f_list_cons 
                                           + 
                                           ($f_list_cons 
                                            * 
                                            -1/1
                                            ($f_list_cons * 1/1 b))
                                           ($f_list_cons * 
                                                         -1/1
                                                         ($f_list_cons 
                                                          * 
                                                          -1 
                                                          ($f_list_cons * 1 a))))

                                          ($f_list_cons * -1/1 ($f_list_cons * -1 2))))))

;---------------------------------
; $evaluate_arith_term
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const a Int)
(declare-const b Real)
(declare-const c Real)
(declare-const f (-> Int Real Int))

; Fully evaluatable terms
; Additions
(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 3))
                                        
                                        5/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 3 1))
                                        
                                        6/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 3 1 4))
                                        
                                        10/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 3 (+ 1 4)))
                                        
                                        10/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 (+ 3 (+ 1 4))))
                                        
                                        10/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (+ (+ 2 3) 1) 4))
                                        
                                        10/1))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ (+ (+ 2 3) 1) (+ (+ 2 3) 1)))
                                        
                                        12/1))

; Products
(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 3))
                                        
                                        6/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 3 1))
                                        
                                        6/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 3 1 4))
                                        
                                        24/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 3 (* 1 4)))
                                        
                                        24/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 (* 3 (* 1 4))))
                                        
                                        24/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (* (* (* 2 3) 1) 4))
                                        
                                        24/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (* (* (* 2 3) 1) 
                                                                 (* (* 2 3) 1)))
                                        
                                        36/1))

; Subtraction
(step test true :rule $unit_test :args (($evaluate_arith_term (- 1 2))
                                        
                                        -1/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (- 1 (- 1 2)))
                                        
                                        2))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- 1 2) (- 1 2)))
                                        
                                        0/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- 1 2) 
                                                                 (- (- 1 2) 2)))
                                        
                                        2))

; Negative terms.
(step test true :rule $unit_test :args (($evaluate_arith_term (- 1))
                                        
                                        -1/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- 1)))
                                        
                                        1))

(step test true :rule $unit_test :args (($evaluate_arith_term (- 2/1))
                                        
                                        -2/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (- 2.0))
                                        
                                        -2/1))

                                        ; Mixed operators
(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 (* 3 4)))
                                        
                                        14/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (* 3 4) 
                                                                 (* 3 4)))
                                        
                                        24/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (* 3 4) 
                                                                 (* 3 (* 3 4))))
                                        
                                        48/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (- 3 4) 
                                                                 (* 3 (* 3 4))))
                                        
                                        35/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (- 3 4) 
                                                                 (* 3 (- 3 4))))
                                        
                                        -4/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (- 3 4) 
                                                                 (* (- 3) (- 3 4))))
                                        
                                        2/1))

; Terms with uninterpreted subterms
; Additions
(step test true :rule $unit_test :args (($evaluate_arith_term ($f_list_cons + a 2))
                                        
                                        ($f_list_cons + 2 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         ($f_list_cons + 
                                                       2
                                                       ($f_list_cons + a 1)))
                                        
                                        ($f_list_cons + 
                                                      3/1
                                                      ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 a 1 4))
                                        
                                        ($f_list_cons + 7/1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 3 (+ 1 4) (* 2 a)))
                                        
                                        ($f_list_cons + 10/1 ($f_list_cons * 2 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ 2 3 (* 2 a) (+ 1 4)))
                                        
                                        ($f_list_cons + 10/1 ($f_list_cons * 2 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ 2 (+ ($f_list_cons * 2 a) (+ 1 4))))
                                        
                                        ($f_list_cons + 7/1 ($f_list_cons * 2 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (+ (+ 2 3) a) 4))
                                        
                                        ($f_list_cons + 9/1 ($f_list_cons * 1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ (+ (+ 2 a) 1) (+ (+ a 3) 1)))
                                        
                                        ($f_list_cons + 7/1 ($f_list_cons * 2/1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (+ (+ 2 a) 1) 
                                                                 (+ (+ b 3) 
                                                                    (+ a b))))
                                        
                                        ($f_list_cons + 
                                                      6/1 
                                                      ($f_list_cons + 
                                                                    ($f_list_cons * 2/1 b)
                                                                    ($f_list_cons * 2/1 a)))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (+ (+ 2 a) 1) 
                                                                 (+ (+ b 3) 
                                                                    (+ (- a) b))))
                                        
                                        ($f_list_cons + 
                                                      6/1 
                                                      ($f_list_cons * 2/1 b))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (+ (+ 2 c) 1) 
                                                                 (+ (+ b 3) 
                                                                    (+ (- a) b))))
                                        
                                        ($f_list_cons 
                                         + 
                                         6/1
                                         ($f_list_cons 
                                          +
                                          ($f_list_cons * 2/1 b)
                                          ($f_list_cons +
                                                        ($f_list_cons * -1 a)
                                                        ($f_list_cons * 1/1 c))))))

; Products
(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 a))
                                        
                                        ($f_list_cons * 2 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (* a 3 1))
                                        
                                        ($f_list_cons * 3 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 a 1 4))
                                        
                                        ($f_list_cons * 8/1 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 3 (* a 4)))
                                        
                                        ($f_list_cons * 24/1 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (* 2 (* a (* 1 4))))
                                        
                                        ($f_list_cons * 8/1 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (* (* (* 2 a) 1) 4))
                                        
                                        ($f_list_cons * 8/1 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (* (* (* 2 3) 1) 
                                                                 (* (* a 3) 1)))
                                        
                                        ($f_list_cons * 18/1 a)))

; Subtraction
(step test true :rule $unit_test :args (($evaluate_arith_term (- 1 a))
                                        
                                        ($f_list_cons + 1 ($f_list_cons * -1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (- 1 (- a 2)))
                                        
                                        ($f_list_cons + 3/1 ($f_list_cons * -1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- 1 a) (- 1 2)))
                                        
                                        ($f_list_cons + 2 ($f_list_cons * -1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- 1 a) (- (- a a) 2)))
                                        
                                        ($f_list_cons + 3/1 ($f_list_cons * -1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- 1 a) (- (- b a) 2)))
                                        
                                        ($f_list_cons + 3/1 ($f_list_cons * -1/1 b))))

(step test true :rule $unit_test :args (($evaluate_arith_term (- a (- b a)))
                                        
                                        ($f_list_cons +
                                                      ($f_list_cons * -1/1 b)
                                                      ($f_list_cons * 2/1 a))))

                                        ; Negative terms.
(step test true :rule $unit_test :args (($evaluate_arith_term (- a))
                                        
                                        ($f_list_cons * -1 a)))

(step test true :rule $unit_test :args (($evaluate_arith_term (- (- a)))
                                        
                                        ($f_list_cons * 1 a)))

                                        ; Mixed operators
(step test true :rule $unit_test :args (($evaluate_arith_term (+ b (* a 4)))
                                        
                                        ($f_list_cons + 
                                                      ($f_list_cons * 1/1 b)
                                                      ($f_list_cons * 4 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (* 3 a) (* b 4)))
                                        
                                        ($f_list_cons + 
                                                      ($f_list_cons * 4 b)
                                                      ($f_list_cons * 3 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (* 3 b) 
                                                                 (* a (* 3 4))))
                                        
                                        ($f_list_cons + 
                                                      ($f_list_cons * 3 b)
                                                      ($f_list_cons * 12/1 a))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (- 3 b) 
                                                                 (* 3 (* a 4))))
                                        
                                        ($f_list_cons +
                                                      3
                                                      ($f_list_cons 
                                                       +
                                                       ($f_list_cons * -1/1 b)
                                                       ($f_list_cons * 12/1 a)))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (- b c) 
                                                                 (* a (- 3 4))))
                                        
                                        ($f_list_cons +
                                                      ($f_list_cons * 1/1 b)
                                                      ($f_list_cons +
                                                                    ($f_list_cons * -1 a)
                                                                    ($f_list_cons * -1/1 c)))))

(step test true :rule $unit_test :args (($evaluate_arith_term (+ (- a b) 
                                                                 (* (- c) (- 3 4))))
                                        
                                        ($f_list_cons +
                                                      ($f_list_cons * -1/1 b)
                                                      ($f_list_cons +
                                                                    ($f_list_cons * 1 a)
                                                                    ($f_list_cons * 1/1 c)))))

; to_int
(step test true :rule $unit_test :args (($evaluate_arith_term (to_int 1.0))
                                        1))

(step test true :rule $unit_test :args (($evaluate_arith_term (to_int 1))
                                        1))

                                        ; NOTE: check the type of this...
(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (- 1)))
                                        -1/1))

                                        ; NOTE: check the type of this...
(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (- 1 2)))
                                        -1/1))

                                        ; NOTE: check the type of this...
(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (+ 1 2)))
                                        3/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (* 1 2)))
                                        2))

                                        ; NOTE: check the type of this...
(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (* (+ 1 2) 
                                                                         2)))
                                        6/1))

                                        ; NOTE: check the type of this...
(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (* (+ 1 2) 
                                                                         (+ 1 2))))
                                        9/1))

(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (* (+ 1.0 2) 
                                                                         2.0)))
                                        6))

(step test true :rule $unit_test :args (($evaluate_arith_term (to_int (* (+ 1 2.0) 
                                                                         (+ 1 2.0))))
                                        9))

(step test true :rule $unit_test :args (($evaluate_arith_term (to_int ($f_list_cons + 1 a)))
                                        ($f_list_cons + 1 ($f_list_cons * 1 a))))

                                        ; Misc.
(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ (- (* -1.0 (* 1.0 (f 1 5.0))) -12.0)
                                            (* -1.0 (- (* -1.0 (* 1.0 (f 1 5.0))) 
                                                       -12.0))))

                                        0))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ 6/1 
                                            (+ (* -1/1 (f 1 5.0))
                                               (+ -4/1 (* 1/1 
                                                          (f 1 5.0))))))

                                        2/1))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ 0 (+ (- (* (- 1.0) 12.0) 
                                                    (* (- 1.0) (f 1 5.0))) 
                                                 (- (* (- 1.0) (f 1 5.0)) 
                                                    (* (- 1.0) 12.0)))))

                                        0))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ (+ (- (f 1 5.0) 5.0) 1) 
                                            (- 5.0 (f 1 5.0))))

                                        1/1))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ (- (* (- 1.0) 10.0) 
                                               (* (- 1.0) (f 0.0))) 
                                            (- (* (- 1.0) (f 0.0)) 
                                               (* (- 1.0) 10.0))))

                                        0/1))

(step test true :rule $unit_test :args (($evaluate_arith_term 
                                         (+ (+ (- (f 0.0) 5.0) 1.0) 
                                            (- 5.0 (f 0.0))))

                                        1/1))

;---------------------------------
; $is_theory_unary_arith_op
;---------------------------------

; TODO: repeating constants just for cohesion of the code...
; Some constants to build arith terms for testing purposes
(declare-const f (-> Int Int))

(step test true :rule $unit_test :args (($is_theory_unary_arith_op f) false))

(step test true :rule $unit_test :args (($is_theory_unary_arith_op -) true))

(step test true :rule $unit_test :args (($is_theory_unary_arith_op to_int) true))

(step test true :rule $unit_test :args (($is_theory_unary_arith_op to_real) true))
