(include "./theory.eo")
(include "./lists.eo")

; Library of auxiliary programs, useful to manipulate many different
; Eunoia constructions.

;------------------------------------
; Eunoia built-in and misc. services
;------------------------------------

; program: $eo_is_eq
; implements: eo::is_eq
; args:
; - t1 Terms: Term to be compared.
; - t2 Terms: Term to be compared.
; return: Simulates the behavior of eo::is_eq.
(program $eo_is_eq ((Terms Type) (t1 Terms) (t2 Terms))
         :signature (Terms Terms) Bool
         (
          (
           ($eo_is_eq t1 t1)

           true
           )

          (; { t1 <> t2 }
           ($eo_is_eq t1 t2)

           false
           )
          )
)

;------------------------
; Reflection mechanisms
;------------------------

; program: $is_theory_op_left_assoc
; args:
; - f (-> T U): A function constant.
; return: >
;    A boolean indicating if f is defined in our theory as 
;    left-assoc/left-assoc-nil. It could receive a user defined function 
;    constant, in which case the function will just return "false", regardless 
;    of the actual associativity of f.
(program $is_theory_op_left_assoc ((T Type) (U Type) (f (-> T U)))
         :signature ((-> T U)) Bool
         (
          (
           ($is_theory_op_left_assoc xor)
           
           true
           )

          (
           ($is_theory_op_left_assoc -)
           
           true
           )

          (
           ($is_theory_op_left_assoc /)
           
           true
           )

          (
           ($is_theory_op_left_assoc div)
           
           true
           )

          (
           ($is_theory_op_left_assoc f)
           
           false
           )
          )
)

; program: $is_theory_op_right_assoc
; args:
; - f (-> T U): A function constant.
; return: >
;    A boolean indicating if f is defined in our theory as 
;    right-assoc/right-assoc-nil. It could receive a user defined function 
;    constant, in which case the function will just return "false", regardless 
;    of the actual associativity of f.
(program $is_theory_op_right_assoc ((T Type) (U Type) (f (-> T U)))
         :signature ((-> T U)) Bool
         (
          (
           ($is_theory_op_right_assoc @cl)
           
           true
           )

          (
           ($is_theory_op_right_assoc or)
           
           true
           )

          (
           ($is_theory_op_right_assoc and)
           
           true
           )

          (
           ($is_theory_op_right_assoc =>)
           
           true
           )

          (
           ($is_theory_op_right_assoc +)
           
           true
           )

          (
           ($is_theory_op_right_assoc *)
           
           true
           )

          (
           ($is_theory_op_right_assoc @varlist)
           
           true
           )

          (
           ($is_theory_op_right_assoc @substitution)
           
           true
           )

          (
           ($is_theory_op_right_assoc f)
           
           false
           )
          )
)

; program: $is_numeric_literal
; args:
; - c A: An arbitrary literal.
; return: A boolean indicating if `c` is a rational or integer literal.
;note: PRE : { decimal literals are syntax sugar for rational literals }
(program $is_numeric_literal ((A Type) (c A))
         :signature (A) Bool

         (
          (
           ($is_numeric_literal c)

           (eo::or (eo::is_z c)
                   (eo::is_q c)
                   ; To deal with numbers with decimal part.
                   (eo::is_ok (eo::to_q c))
                   )
           )
          )
         )

;-------------
; @VarList
;-------------

; TODO: this should be implemented using f-list functions
; program: varlist_concat
; args:
; - varlist_concat nil:
; return:
(program $varlist_concat ((A Type) (hd A) (tl @VarList :list)
                         (varlist_2 @VarList))
  :signature (@VarList @VarList) @VarList

  (
   (
    ($varlist_concat (@varlist hd tl) varlist_2)
    
    ($f_list_cons @varlist 
                 hd
                 ($varlist_concat tl varlist_2))
    )

   (
    ($varlist_concat @varlist.nil varlist_2)
    
    varlist_2
    )
   )
)

; program: varlist_reverse
; args:
; - A Type:
; - hd A:
; - tl @VarList:
; return:
(program $varlist_reverse ((A Type) (hd A) (tl @VarList :list))
  :signature (@VarList) @VarList
  (
   (
    ($varlist_reverse (@varlist hd tl))

    ($varlist_concat ($varlist_reverse tl) 
                    ($f_list_cons @varlist hd @varlist.nil))
    )
   (
    ($varlist_reverse @varlist.nil)

    @varlist.nil
    )
  )
)

; program: $varlist_zip
; args:
; - list_1 @VarList: Some @VarList.
; - list_2 @VarList: Some @VarList.
; return:
;  The zip of the received @VarLists, as another @VarList.
(program $varlist_zip ((A Type) (hd_1 A) (tl_1 A :list) (hd_2 A) (tl_2 A :list))
         :signature (@VarList @VarList) @VarList

         (
          (
           ($varlist_zip (@varlist hd_1 tl_1) (@varlist hd_2 tl_2))

           ($f_list_cons @varlist
                         ($f_list_cons @varlist hd_1 (@varlist hd_2 @varlist.nil))
                         ($varlist_zip tl_1 tl_2))
           )

          (
           ($varlist_zip @varlist.nil @varlist.nil)

           @varlist.nil
           )
          )
)

; TODO: implement this as a higher-order program, once it becomes feasible
; program: $varlist_flag_members
; args:
; - varlist_1 @VarList: >
;   A list for whose elements we want to determine membership with respect to
;   varlist_2.
; - varlist_2 @VarList: >
;   A list against which determine membership of each element from varlist_1.
; return:
;   A @VarList of booleans such that its i-th element indicates if the 
;   i-th element from varlist_1 also occurs in varlist_2.
(program $varlist_flag_members ((A Type) 
                        (hd_1 A) (tl_1 A :list)
                        (varlist_2 @VarList))

         :signature (@VarList @VarList) @VarList

         (
          (
           ($varlist_flag_members (@varlist hd_1 tl_1) varlist_2)
           
           ($f_list_cons @varlist 
                         ($f_list_contains_elem @varlist hd_1 varlist_2)
                         ($varlist_flag_members tl_1 varlist_2))
           )

          (
           ($varlist_flag_members @varlist.nil varlist_2)

           @varlist.nil
           )
          )
 )

; program: $varlist_hd
; args:
; - varlist @VarList: A @VarList.
; return:
;    The first element of the given @VarList.
; note:
;    PRE : { len(varlist) > 0 }
(program $varlist_hd ((A Type) (hd A) (tail @VarList))

         :signature (@VarList) A

         (
          (
           ($varlist_hd (@varlist hd tail))
           
           hd
           )
          )
 )

; program: $varlist_hd
; args:
; - varlist @VarList: A @VarList.
; return:
;    The tail of the given @VarList; "varlist" could be nil.
(program $varlist_tl ((A Type) (hd A) (tail @VarList))

         :signature (@VarList) @VarList

         (
          (
           ($varlist_tl @varlist.nil)
           
           @varlist.nil
           )

          (
           ($varlist_tl (@varlist hd tail))
           
           tail
           )
          )
 )

; program: $varlist_contains_elem
; args:
; - varlist @VarList: A @VarList of elements of some type A.
; - elem A: An element for which we want to test membership
; return: A boolean indicating if "elem" appears in "varlist".
(program $varlist_contains_elem ((A Type) (elem A) (head A) (tail @VarList :list))
         :signature (@VarList A) Bool
         (
          (
           ($varlist_contains_elem @varlist.nil elem)

           false
           )
          
          (
           ($varlist_contains_elem (@varlist elem tail) elem)

           true
           )

          (; { head <> elem }
           ($varlist_contains_elem (@varlist head tail) elem)

           ($varlist_contains_elem tail elem)
           )
          )
)

; program: $varlist_remove_elem
; args:
; - varlist @VarList: A @VarList of elements of some type A.
; - elem A: An element which we want to remove from "varlist".
; return: >
;    A new @VarList that is equal to "varlist" except that it does not
;    contain the first occurrence of "elem".
(program $varlist_remove_elem ((A Type) (elem A) (head A) (tail @VarList :list))
         :signature (@VarList A) @VarList
         (
          (
           ($varlist_remove_elem @varlist.nil elem)

           @varlist.nil
           )
          
          (
           ($varlist_remove_elem (@varlist elem tail) elem)

           tail
           )

          (; { head <> elem }
           ($varlist_remove_elem (@varlist head tail) elem)

           ($f_list_cons @varlist head
                         ($varlist_remove_elem tail elem))
           )
          )
)


;-------------
; Clauses
;-------------

; program: from_cl
; args:
; - T Bool: A proposition.
; return: >
;   For a unit clause, built with @cl, removes the top @cl if 
;   any, returning the only disjunct. Otherwise, returns T.
(program $from_cl ((T Bool))
    :signature (Bool) Bool
    (
     (

      ($from_cl (@cl T)) 
      T
      )

     (
      ($from_cl T) 

      T
      )
     )
    )

; program: to_cl
; args:
; - T Bool: A proposition.
; return: >
;   Embeds T within a unit clause built with @cl, only
;   if T is not a unit clause built with @cl itself. 
(program $to_cl ((T Bool))
    :signature (Bool) Bool
    (
     (
      ($to_cl (@cl T))

      (@cl T)
      )

     (
      ($to_cl T) 

      (@cl T)
      )
    )
)

; TODO: is it ok?
; program: prop_syntax_eq
; args:
; - phi_1 Bool: A proposition.
; - phi_2 Bool: A proposition.
; return: A boolean indicating if phi_1 and phi_2 are syntactically equal.
(program $prop_syntax_eq ((phi Bool) (psi Bool))
  :signature (Bool Bool) Bool
  (
   (
    ($prop_syntax_eq phi phi) 

    true
    )

   (; { phi <> psi }
    ($prop_syntax_eq phi psi) 
    
    false
    )
   )
)

; program: cl_equal
; args:
; - cl_1 Bool: A clause, built with @cl.
; - cl_2 Bool: A clause, built with @cl.
; return: >
;   A boolean indicating if cl_1 and cl_2 are equal modulo permutations.
(program $cl_equal ((cl_1 Bool) (cl_2 Bool))
  :signature (Bool Bool) Bool
  (
   (
    ($cl_equal cl_1 cl_2)

    ($f_list_equal @cl cl_1 cl_2)
    )
  )
)

; program: $cl_disjunct
; args:
; - cl_1 Bool: A clause built with @cl.
; - cl_2 Bool: A clause built with @cl.
; return: >
;   The clause formed by concatenating the literals of `cl_1` and `cl_2`, taking
;   into account the semantics of `@empty_cl`.
(program $cl_disjunct ((clause Bool) (left_disjunct Bool) (right_disjunct Bool)
                       (left_tail Bool :list) (right_tail Bool :list))
                       
         :signature (Bool Bool) Bool
         (
          (
           ($cl_disjunct @empty_cl clause)

           clause
           )

          (; {clause != @empty_cl }
           ($cl_disjunct clause @empty_cl)

           clause
           )

          (
           ($cl_disjunct (@cl left_disjunct) 
                         (@cl right_disjunct right_tail))

           (@cl left_disjunct right_disjunct right_tail)
           )

          (; { left_tail != false}
           ($cl_disjunct (@cl left_disjunct left_tail) 
                         (@cl right_disjunct right_tail))

           ($f_list_cons @cl 
                         left_disjunct 
                         ($cl_disjunct left_tail
                                       (@cl right_disjunct right_tail)))
           )
          )
)

; program: convert_or_to_cl
; args:
; - or_clause Bool : >
;   Clause to convert, built with the "or" operator.
; - accum Bool : Partial result accumulator
; return: >
;   A clause equivalent to "or_clause", built exclusively with @cl.
(program $convert_or_to_cl ((or_clause Bool) (disjunct_1 Bool) (disjunct_2 Bool :list))
  :signature (Bool) Bool
  (
   (
    ($convert_or_to_cl (or disjunct_1 disjunct_2))

    ($f_list_cons @cl disjunct_1 ($convert_or_to_cl disjunct_2))
    )

   ; { disjunct_1 is not built with "or" }
   (
    ($convert_or_to_cl disjunct_1)

    disjunct_1)
   )
)

; program: transform_not_and
; args:
; - ls Bool: A conjunction of terms.
; return: >
;   Applies De Morgan's law over the conjuncts of "ls", returning a new clause
;   built with @cl.
(program $de_morgan_not_and ((l Bool) (ls Bool))
  :signature (Bool) Bool
  (
   (
    ($de_morgan_not_and (and l ls))

    (@cl (not l) ($from_cl ($de_morgan_not_and ls)))
    )

   (
    ($de_morgan_not_and l) 

    (@cl (not l))
    )
  )
)


; TODO: implement this as a higher-order program, once it becomes feasible
; program: $flag_duplicates
; args:
; - hd Bool:
; - tl Bool:
; return:
(program $flag_duplicates ((A Type) (B Type)
                           (f (-> A A B))
                           (nil_elem A)
                           (hd A) (tl A :list))
         :signature ((-> A A B) A A) @VarList

         (
          (
           ($flag_duplicates f nil_elem (f hd tl))

           ($varlist_concat
            ($f_list_cons @varlist 
                          ($f_list_contains_elem f hd tl)
                          @varlist.nil)
            ($flag_duplicates f nil_elem tl))
           )

          (
           ($flag_duplicates f nil_elem nil_elem)

           @varlist.nil
           )

          ; { hd <> nil_elem }
          (
           ($flag_duplicates f nil_elem hd)

           ($f_list_cons @varlist 
                         false
                         @varlist.nil)
           )
          )
)

; program: cl_remove_duplicates
; args:
; - clause Bool: A clause from which we want to delete duplicates.
; return: A clause that contains every element from "clause", without duplicates.
(program $cl_remove_duplicates ((clause Bool))
         :signature (Bool) Bool
         (
          (
           ($cl_remove_duplicates clause)

           ($f_list_filter @cl false clause 
                           ($flag_duplicates @cl false clause))
           )
          )
)

;-------------
; implication
;-------------

; program: rewrite_implication
; args:
; - implication Bool: >
;   An implication over which we want to apply simplifying rewrites.
; return:
;   A proposition that is equivalent to "implication", but that is
;   not built with =>.
(program $rewrite_implication ((phi_1 Bool) (phi_2 Bool))
         :signature (Bool) Bool
         (; We apply semantics preserving rewrites.
          (
           ($rewrite_implication (=> (not phi_1) (not phi_2)))
          
          ($rewrite_implication (=> phi_2 phi_1))
          )

          (
           ($rewrite_implication (=> false phi_1))
          
          true
          )

          (
           ($rewrite_implication (=> phi_1 true))

          true
          )

          (
           ($rewrite_implication (=> true phi_1))

          phi_1
          )

          (
           ($rewrite_implication (=> phi_1 false))

          (not phi_1)
          )

          (
           ($rewrite_implication (=> phi_1 phi_1))

          true
          )

          (
           ($rewrite_implication (=> (not phi_1) phi_1))
 
          phi_1
          )

          (
           ($rewrite_implication (=> (not phi_1) (not phi_1)))

          (not phi_1)
          )
          )
)

; program: rewrite_equivalence
; args:
; - equivalence Bool: >
;   An equivalence over which we want to apply simplifying rewrites.
; return:
;   A proposition that is equivalent to "equivalence", but that is
;   not built with =.
(program $rewrite_equivalence ((phi_1 Bool) (phi_2 Bool))
         :signature (Bool) Bool
         (; We apply semantics preserving rewrites.
          (
           ($rewrite_equivalence (= (not phi_1) (not phi_2)))
          
          ($rewrite_equivalence (= phi_2 phi_1))
          )

          (
           ($rewrite_equivalence (= phi_1 phi_1))

          true
          )

          (
           ($rewrite_equivalence (= phi_1 (not phi_1)))

          false
          )

          (
           ($rewrite_equivalence (= (not phi_1) phi_1))

          false
          )

          (
           ($rewrite_equivalence (= true phi_1))

          phi_1
          )

          (
           ($rewrite_equivalence (= phi_1 true))

          phi_1
          )

          (
           ($rewrite_equivalence (= phi_1 false))

          (not phi_1)
          )

          (
           ($rewrite_equivalence (= false phi_1))

          (not phi_1)
          )
          )
         )


;-------------
; contexts
;-------------

; program: context_get_substitute
; args:
; - context Bool: A context built with @ctx.
; - id A: A variable name, with which index "context".
; return: The value associated with variable "id", in context "context".
(program $context_get_substitute ((A Type) (id A) (B Type)
                    (value B) (hd Bool) (tl Bool :list)
                    (varlist @VarList)
                    (subst Bool))
         :signature (Bool A) B
         (
          (; Just to discard possible leading @ctx constructor
           ($context_get_substitute (@ctx varlist subst) id)
           
           ($context_get_substitute subst id)
           )

          (; Contexts are nested.
           ($context_get_substitute (and (@ctx varlist subst)) id)
           
           ($context_get_substitute subst id)
           )

          (; Since id is bound within the definition of the context, it appears
           ; in the (@var (@varlist id) id) form.
           ($context_get_substitute (and (= (@var (@varlist id) id) value) tl) id)
           
           value
           )

          ; { hd =/= (= id value), for some value "value"} 
          (
           ($context_get_substitute (and hd tl) id)
           
           ($context_get_substitute tl id)
           )

          (; Since id is bound within the definition of the context, it appears
           ; in the (@var (@varlist id) id) form.
           ($context_get_substitute (= (@var (@varlist id) id) value) id)
           
           value
           )
          )
)

; program: $context_get_var_subst_pairs
; args:
; - context Bool: A context built with @ctx.
; - variables @VarList: >
;   A @VarList with variables' names, with which to index "context".
; return: >
;   A @VarList with the values associated with each variable from, and in the 
;   same order as in, "variables"; in the form of pairs (variable, value),
;   built also as @VarList.
(program $context_get_var_subst_pairs ((A Type) (id A) (B Type)
                                      (value B) (varlist @VarList) 
                                      (context Bool) (and_list Bool)
                                      (ids @VarList :list))
         :signature (Bool @VarList) @VarList
         (
          (
           ($context_get_var_subst_pairs context (@varlist id ids))
           
           ($f_list_cons @varlist 
                        ($f_list_cons @varlist id
                                      ($f_list_cons @varlist 
                                                    ($context_get_substitute context id) @varlist.nil))
                        ($context_get_var_subst_pairs context ids))
           )

          (
           ($context_get_var_subst_pairs context @varlist.nil)
           
           @varlist.nil
           )
          )
)

; program: $context_get_variables
; args:
; - context Bool: A context built with @ctx.
; return: >
;   A @VarList with the variables bound by "context".
(program $context_get_variables ((varlist @VarList) (subst Bool) (any Bool) 
                                 (eqs Bool :list))
         :signature (Bool) @VarList
         (
          (
           ($context_get_variables (@ctx varlist subst))
           
           ($f_list_remove_duplicates @varlist @varlist.nil
                                      ($varlist_concat varlist ($context_get_variables subst)))
           )

          (
           ($context_get_variables (and (@ctx varlist subst)))
           
           ($f_list_remove_duplicates @varlist @varlist.nil
                                      ($varlist_concat varlist ($context_get_variables subst)))
           )

          (; { any <> (@ctx varlist subst) }
           ($context_get_variables (and any eqs))
           
           ($context_get_variables eqs)
           )

          (
           ($context_get_variables true)

                      @varlist.nil
           )
          )
)

; program: $context_get_vars_substs
; args:
; - context Bool: A context built with @ctx.
; - variables @VarList: >
;   A @VarList with variables' names, with which to index "context".
; return: >
;   A @VarList with the values associated with each variable from, and in the 
;   same order as in, "variables".
(program $context_get_vars_substs ((A Type) (id A) (B Type)
                                      (value B) (varlist @VarList) 
                                      (context Bool) (and_list Bool)
                                      (ids @VarList :list))
         :signature (Bool @VarList) @VarList
         (
          (
           ($context_get_vars_substs context (@varlist id ids))
           
           ($f_list_cons @varlist 
                         ($context_get_substitute context id)
                         ($context_get_vars_substs context ids))
           )

          (
           ($context_get_vars_substs context @varlist.nil)
           
           @varlist.nil
           )
          )
)

; program: $context_var_is_fixed
; args:
; - context Bool: >
;    A context built with @ctx, in a normalized form, where there are,
;    at most, one binding defined for a given variable.
; - var A: >
;   Variable for which we want to know if it is fixed, as indicated
;   in "context".
; return: >
;   A boolean indicating if "var" is fixed in "context".
(program $context_var_is_fixed ((A Type) (var A) (var_2 A)
                                (B Type) (any B)
                                (eqs Bool :list)
                                (varlist @VarList) (and_list Bool))
         :signature (Bool A) Bool
         
         (
          (; Case: most nested @ctx.
           ($context_var_is_fixed (and (@ctx varlist and_list)) var)

           ($context_var_is_fixed and_list var)
           )

          (; Just to discard @ctx constructor
           ($context_var_is_fixed (@ctx varlist and_list) var)

           ($context_var_is_fixed and_list var)
           )

          (
           ($context_var_is_fixed 
            (and (= (@var (@varlist var) var) (@var (@varlist var) var))) var)

           true
           )

          (; { (@var (@varlist var) var) <> any}
           ($context_var_is_fixed (and (= (@var (@varlist var) var) any)) var)

           false
           )

          (; { (@var (@varlist var) var) <> var_2}
           ($context_var_is_fixed (and (= var_2 any)) var)

           false
           )

          (
           ($context_var_is_fixed 
            (and (= (@var (@varlist var) var) (@var (@varlist var) var)) eqs) var)
           
           true
           )

          (; { (@var (@varlist var) var) <> any}
           ($context_var_is_fixed (and (= (@var (@varlist var) var) any) eqs) var)

           false
           )

          (; { (@var (@varlist var) var) <> var_2}
           ($context_var_is_fixed (and (= var_2 any) eqs) var)
           
           ($context_var_is_fixed eqs var)
           )

          (; This is the last "element" of our representation of 
           ; contexts.
           ($context_var_is_fixed (and true) var)

           false
           )
          )
)

; TODO: re-implement this as a map once programs are first-class values
; program: $context_vars_are_fixed
; args:
; - context Bool: A context, built with @ctx.
; - vars @VarList: >
;   Variables for which we want to know if they appear fixed in "context".
; return: >
;   A boolean indicating if every variable in "vars" appear fixed in "context".
(program $context_vars_are_fixed ((A Type) (var A) (tl @VarList :list)
                                  (context Bool))
         :signature (Bool @VarList) Bool
         
         (
          (
           ($context_vars_are_fixed context (@varlist var tl))

           (eo::and ($context_var_is_fixed context var)
                    ($context_vars_are_fixed context tl))
           )

          (
           ($context_vars_are_fixed context @varlist.nil)

           true
           )
          )
)


; program: $context_var_is_defined
; args:
; - context Bool: A context, built with @ctx.
; - var A: A given variable.
; return: >
;    A boolean indicating if "var" is defined in "context".
(program $context_var_is_defined ((A Type) (var A) (eq Bool)
                                  (varlist @VarList :list) (and_list Bool :list))
         :signature (Bool A) Bool
         
         (
          (
           ($context_var_is_defined (@ctx varlist and_list) var)

           (eo::or 
            ($f_list_contains_elem @varlist var varlist)
            ($context_var_is_defined and_list var))
           )

          (; Case: nested @ctx.
           ($context_var_is_defined (and (@ctx varlist and_list)) var)

           (eo::or 
            ($f_list_contains_elem @varlist var varlist)
            ($context_var_is_defined and_list var))
           )

          (; { eq <> @ctx }
           ($context_var_is_defined (and eq and_list) var)

           ($context_var_is_defined and_list var)
           )

          (
           ($context_var_is_defined true var)

           false
           )
          )
)

; TODO: 
; program: $context_vars_are_defined
; args:
; - context Bool: A context, built with @ctx.
; - vars @VarList: A @VarList containing variables.
; return: >
;    A boolean indicating if at least some variable in "vars" is defined in "context".
(program $context_vars_are_defined ((A Type) (var A)
                                  (vars @VarList :list) (context Bool))
         :signature (Bool @VarList) Bool
         
         (
          (
           ($context_vars_are_defined context (@varlist var vars))

           (eo::or
            ($context_var_is_defined context var)
            ($context_vars_are_defined context vars))
           )

          (
           ($context_vars_are_defined context @varlist.nil)

           false
           )
          )
)

;TODO
; program: $context_is_extended
; args:
; - new_ctx Bool: A context built with @ctx.
; - old_ctx Bool: A context built with @ctx.
; return: >
;    Returns a boolean that indicates if new_ctx is defined just as
;    an extension of old_ctx. We allow for new_ctx to be equal to
;    old_ctx.
(program $context_is_extended ((old_ctx Bool) (new_ctx Bool)
                               (varlist @VarList) (eq Bool) (and_list Bool :list))
    :signature (Bool Bool) Bool
    (
        (; We admit for the contexts to be equal
         ($context_is_extended new_ctx new_ctx) 

         true
         )

        (; { old_ctx <> new_ctx }
         ($context_is_extended (@ctx varlist and_list) old_ctx)

         ($context_is_extended and_list old_ctx)
         )
        
        (
         ($context_is_extended (and old_ctx) old_ctx)

         true
         )

        (; { (@ctx varlist and_list) <> new_ctx }
         ($context_is_extended (and (@ctx varlist and_list)) old_ctx)

         ($context_is_extended and_list old_ctx)
         )

        (; { eq <> @ctx }
         ($context_is_extended (and eq and_list) old_ctx)

         ($context_is_extended and_list old_ctx)
         )

        (
         ($context_is_extended true old_ctx)

           false
           )
        )
    )

;-------------
; let
;-------------

; TODO: once programs can be passed and used, abstract the logic of these
;       functions into a single program
; program: let_get_vars
; args:
; - let_get_vars nil:
; return:
(program $let_get_vars ((let_type Type) (var_defs @VarList)
                       (body_type Type) (body body_type)
                       (A Type) (var_values A)
                       (B Type) (nested_func_app B))

         :signature (let_type) @VarList
         (
          (
           ($let_get_vars (_ (@let var_defs body) var_values))

           var_defs
           )

          (; { nested_func_app =/= (@let ...) }
           ($let_get_vars (_ nested_func_app var_values))

           ($let_get_vars nested_func_app)
           )
          )
         )

; program: let_get_values
; args:
; - let_get_vars nil:
; return:
(program $let_get_values ((let_type Type) (varlist @VarList)
                         (body_type Type) (body body_type)
                         (B Type) (nested_func_app B)
                         (A Type) (value A))

         :signature (let_type) @VarList
         (
          (
           ($let_get_values (_ (@let varlist body) value))

           ($f_list_cons @varlist value @varlist.nil)
           )

          (
           ; { nested_func_app =/= (@let ...) }
           ($let_get_values (_ nested_func_app value))

           ($varlist_reverse ($f_list_cons @varlist 
                                         value 
                                         ($let_get_values nested_func_app)))
           )
          
          )
         )

; program: let_get_body
; args:
; - let_get_body nil:
; return:
(program $let_get_body ((let_type Type) (varlist @VarList)
                         (body_type Type) (body body_type)
                         (B Type) (nested_func_app B)
                         (A Type) (value A))

         :signature (let_type) body_type
         (
          (
           ($let_get_body (_ (@let varlist body) value))

           body
           )

          (
           ; { nested_func_app =/= (@let ...) }
           ($let_get_body (_ nested_func_app value))

           ($let_get_body nested_func_app)
           )
          
          )
         )

; program: let_get_vars_substitutes
; args:
; - let_get_vars_substitutes nil:
; return:
(program $let_get_vars_substitutes ((B Type) (x B)
                                   (vardefs @VarList :list)
                                   (U Type) (value_x U) 
                                   (parameters @VarList :list))

         :signature (@VarList @VarList) @VarList
         (
          (
           ($let_get_vars_substitutes (@varlist x vardefs)
                                     (@varlist value_x parameters))

           ($f_list_cons @varlist 
                        ($f_list_cons @varlist x value_x)
                        ($let_get_vars_substitutes vardefs parameters))
           )

          (
           ($let_get_vars_substitutes @varlist.nil @varlist.nil)

           @varlist.nil
           )
          )
)

;-------------
; Unbounded occurrences of variables
;-------------

; program: $fv
; args:
; - term A: Term from which we want to extract free occurrences of variables.
; return: A @VarList with free occurrences of variables in "term".
(program $fv ((A Type)
              (vars @VarList)
              (bool_body Bool)
              (E Type) (x E)
              (F Type) (G Type) (function (-> F G)) (actual_argument F))
         :signature (A) @VarList

         (
          (
           ($fv (forall vars bool_body))

           ; TODO: repeating stuff...
           ($f_list_filter @varlist @varlist.nil
                           ($fv bool_body)
                           ($varlist_flag_members ($fv bool_body) 
                                          vars))
           )

          (
           ($fv (exists vars bool_body))

           ; TODO: repeating stuff...
           ($f_list_filter @varlist @varlist.nil
                           ($fv bool_body)
                           ($varlist_flag_members ($fv bool_body) 
                                          vars))
           )

          (; We consider (@var varlist x) as our representation of variables 
           ; introduced by some binder. That is, variables that are actually
           ; bound by some enclosing binder. For reasoning purposes within $fv, 
           ; we just use 'x' as the representation of the variable.
           ; In particular, it simplifies membership testing of it against a list of 
           ; binding occurrences of variables, from a given binder.
           ($fv (@var (@varlist x) x))

           ($f_list_cons @varlist 
                         ; (@var (@varlist x) x) 
                         x
                         @varlist.nil)
           )

          (
           ($fv (_ function actual_argument))
           
           ; TODO: repeating stuff...
           ($f_list_filter @varlist @varlist.nil 
                           ($varlist_concat ($fv function)
                                            ($fv actual_argument))
                           ($flag_duplicates @varlist @varlist.nil
                            ($varlist_concat ($fv function)
                                             ($fv actual_argument))))
           )

          (
           ($fv @empty_cl)

           @varlist.nil
           )

          ; propositional logic
          (
           ($fv true)

           @varlist.nil
           )

          (
           ($fv false)

           @varlist.nil
           )

          ; { x is a var }
          (; This should represent a definition introduced in the smt problem.
           ($fv x)

           ($f_list_cons @varlist x @varlist.nil)
           )
          )
)

;-------------
; Substitution
;-------------

; Manipulation/application of substitutions.

; program: $substitution_contains_substitute
; args:
; - substitutions @Substitution: Substitution that we want to query.
; - var Vars: >
;    A variable for which we want to determine if "substitutions" contains
;    a substitute.
; return: >
;    A boolean indicating if "substitutions" contains a substitute for "var".
(program $substitution_contains_substitute ((Vars Type) (Values Type)
                                            (var Vars) (var2 Vars) (value Values) 
                                            (substitutions @Substitution :list))
         :signature (@Substitution Vars) Bool
         (
          (
           ($substitution_contains_substitute 
            (@substitution (@substitute var value) substitutions)
            var)

           true
           )

          (; {var2 <> var}
           ; Assuming that var is actually mentioned in the substitution.
           ($substitution_contains_substitute 
            (@substitution (@substitute var2 value) substitutions)
            var)

           ($substitution_contains_substitute substitutions var)
           )

          (; {var' <> var}
           ; Assuming that var is actually mentioned in the substitution.
           ($substitution_contains_substitute @substitution.nil var)

           false
           )
          )
)

; define: $substitution_extend
; args:
; - substitutions @Substitution: The substitution that we want to extend.
; - var Variables: >
;    A variable for which we want to define a substitute, extending "substitutions".
; - value Values: >
;    The substitute for "var" with which we want to extend "substitutions".
; return: >
;    The corresponding extension to "substitutions", provided "var" is not already
;    contained in the domain of "substitutions".
(define $substitution_extend ((substitutions @Substitution)
                              (Variables Type :implicit) (Values Type :implicit)
                              (var Variables) (value Values))

        (eo::ite ($substitution_contains_substitute substitutions var)

                 substitutions
                 
                 ($f_list_cons @substitution
                               (@substitute var value) substitutions)
                 )
        ;TODO: cannot pass this type-check
        ;; :type (-> @Substitution (-> Variables (-> Values @Substitution)))
)

; program: $substitution_build
; args:
; - variables @VarList: Variables that will be included in the substitution.
; - values @Varlist: >
;    Substitutes for each variable mentioned in "variables", in the same order 
;    as in "variables".
; return: The corresponding @Substitution.
(program $substitution_build ( (Vars Type) (Values Type) (var Vars) (value Values)
                               (vars_tail @VarList :list) (values_tail @VarList :list))
         :signature (@VarList @VarList) @Substitution
         (
          (
           ($substitution_build @varlist.nil @varlist.nil)

           @substitution.nil
           )

          (
           ($substitution_build (@varlist var vars_tail) (@varlist value values_tail))

           ($substitution_extend ($substitution_build vars_tail values_tail) var value)
           )
          )
)

; program: $substitution_build_from_pairs
; args:
; - variables_values @VarList: >
;    A @VarList of pairs of the form (variable, value), meaning that "variable"
;    should be substituted by "value".
; return: The corresponding @Substitution.
(program $substitution_build_from_pairs ((Vars Type) (Values Type) (var Vars) 
                                         (value Values) (pairs_tail @VarList :list))
         :signature (@VarList) @Substitution
         (
          (
           ($substitution_build_from_pairs @varlist.nil)

           @substitution.nil
           )

          (
           ($substitution_build_from_pairs (@varlist (@varlist var value) pairs_tail))

           ($substitution_extend ($substitution_build_from_pairs pairs_tail) var value)
           )
          )
)

; program: $substitution_build_from_context
; args:
; - context Bool: A context from which we want to build a substitution function.
; return: The corresponding @Substitution.
(program $substitution_build_from_context ((context Bool))
         :signature (Bool) @Substitution
         (
          (
           ($substitution_build_from_context context)
           
           ($substitution_build_from_pairs
                           ($context_get_var_subst_pairs context 
                                                         ($context_get_variables context)))
           )
          )
)

; program: $substitution_remove_substitutes
; args:
; - $substitution_remove_substitutes nil:
; return:
(program $substitution_remove_substitutes ((Vars Type) (Values Type) (var Vars) 
                                           (value Values)
                                           (vars @VarList) 
                                           (substitutions @Substitution :list))
         :signature (@Substitution @VarList) @Substitution

         (
          (
           ($substitution_remove_substitutes 
            (@substitution (@substitute var value) substitutions) vars)
           ; If var is present in vars, we remove var's substitute from
           ; the whole set of substitutions
           (eo::ite ($varlist_contains_elem vars var)
                    
                    ($substitution_remove_substitutes 
                     substitutions
                     ($varlist_remove_elem vars var))

                    ($substitution_extend 
                     ($substitution_remove_substitutes substitutions vars)
                     var value))
           )

          (
           ($substitution_remove_substitutes @substitution.nil vars)

           @substitution.nil
           )
          )
)

; program: $substitution_get_value
; args:
; - Var Type:
; - Value Type:
; return:
(program $substitution_get_value ((Vars Type) (Values Type) (var Vars) (var2 Vars)
                                  (value Values)
                                  (substitutions @Substitution :list))
         :signature (@Substitution Vars) Values
         (
          (
           ($substitution_get_value 
            (@substitution (@substitute var value) substitutions)
            var)

           value
           )

          (; {var2 <> var}
           ; Assuming that var is actually mentioned in the substitution.
           ($substitution_get_value 
            (@substitution (@substitute var2 value) substitutions)
            var)

           ($substitution_get_value substitutions var)
           )
          )
)

; program: $substitution_apply
; args:
; - term Terms: A given term upon which we want to apply the substitution.
; - substitution @Substitution: The substitution that we want to apply.
; return: The term resulting of applying "substitution" over "term".
(program $substitution_apply ((Terms Type) (x Terms)
                      (vars @VarList)
                      (bool_body Bool)
                      (substitution @Substitution)
                      (A Type) (B Type) (function (-> A B))
                      (actual_argument A))
         :signature (Terms @Substitution) Terms

         (
          (
           ($substitution_apply (forall vars bool_body) substitution)
                                  
           (forall vars
                   ($substitution_apply bool_body ($substitution_remove_substitutes substitution vars)))
           )

          (
           ($substitution_apply (exists vars bool_body) substitution)
                                  
           (exists vars 
              ($substitution_apply bool_body ($substitution_remove_substitutes 
                                              substitution vars)))
           )

          (; We consider (@var varlist x) as our representation of variables 
           ; introduced by some binder. For reasoning purposes within $substitution_apply, 
           ; we just use 'x' as the representation of the variable.
           ($substitution_apply (@var (@varlist x) x) substitution)

           (eo::ite ($substitution_contains_substitute substitution x)

                    ($substitution_apply x substitution)

                    (@var (@varlist x) x))
           )

          (
           ($substitution_apply (_ function actual_argument) substitution)
           
           ; TODO: at some point, could we do some higher-order reasoning,
           ; requiring to be able to substitute function constants?
           (_ ($substitution_apply function substitution)
              ($substitution_apply actual_argument substitution))
           )

          (
           ($substitution_apply @empty_cl substitution)

           @empty_cl
           )

          ; propositional logic
          (
           ($substitution_apply true substitution)

           true
           )

          (
           ($substitution_apply false substitution)

           false
           )

          ; { x is a var }
          (
           ($substitution_apply x substitution)
           (eo::ite ($substitution_contains_substitute substitution x)

                    ($substitution_get_value substitution x)

                    x)
           )
          )
)


;-----------
; Arithmetic
;-----------


; The following programs help to inspect terms without resorting to program 
; patterns (to avoid problems that can arise with right/left-assoc-nil constants
; and patterns).

; program: $is_addition
; args:
; - term A: An arbitrary arith term.
; return: A boolean indicating if `term` is built with `+`.
(program $is_addition ((A Type) (lhs A) (rhs A :list) (term A))
         :signature (A) Bool
         (
          (
           ($is_addition (+ lhs rhs))

           true
           )

          (
           ($is_addition term)

           false
           )
          )
         )

; program: $addition_get_lhs
; args:
; - term A: An arithmetic term of the form (+ lhs rhs).
; return: The first summand of `term`.
(program $addition_get_lhs ((A Type) (lhs A) (rhs A :list) (term A))
         :signature (A) A
         (
          (
           ($addition_get_lhs (+ lhs rhs))

           lhs
           )
          )
         )

; program: $addition_get_rhs
; args:
; - term A: An arithmetic term of the form (+ lhs rhs).
; return: The second summand of `term`.
(program $addition_get_rhs ((A Type) (lhs A) (rhs A :list) (term A))
         :signature (A) A
         (
          (
           ($addition_get_rhs (+ lhs rhs))

           rhs
           )
          )
         )

; program: $is_uninterpreted_constant
; args:
; - term A: An arbitrary arith term.
; return: >
;   A boolean indicating if `term` is a uninterpreted constant, or an 
;   uninterpreted function applied over some arbitrary term.
(program $is_uninterpreted_constant ((A Type) (lhs A) (rhs A :list) (term A))
         :signature (A) Bool
         (
          (
           ($is_uninterpreted_constant (+ lhs rhs))

           false
           )

          (
           ($is_uninterpreted_constant (* lhs rhs))

           false
           )
          
          (
           ($is_uninterpreted_constant (/ lhs rhs))

           false
           )

          (
           ($is_uninterpreted_constant (- lhs rhs))

           false
           )

          (
           ($is_uninterpreted_constant (- term))

           false
           )

          (
           ($is_uninterpreted_constant term)

           (eo::ite ($is_numeric_literal term)

                    false
                    
                    ; { not ($is_numeric_literal term) }
                    ; The only possibility that remains is for `term` to be
                    ; an uninterpreted constant or function (applied).
                    true)
           )
          )
         )

; program: $is_constant_times_variable
; args:
; - term A: An arithmetic term.
; return: >
;   Returns a boolean indicating if `term` = (* a variable), for some numerical
;   literal "a", and "variable" being an arbitrary expression involving
;   uninterpreted constants and/or functions.
(program $is_constant_times_variable ((A Type) (constant A) (term A)
                                      (variable A :list))
         :signature (A) Bool
         (
          ( 
           ($is_constant_times_variable (* constant variable))

           (eo::ite (eo::and 
                     ($is_uninterpreted_constant variable)
                     ($is_numeric_literal constant))

                    true

                    ; { not (eo::and 
                    ;   ($is_uninterpreted_constant variable)
                    ;   ($is_numeric_literal constant)) }
                    false)
            )

          ( ; { term != (* constant variable) }
           ($is_constant_times_variable term)

           false
           )
          )
         )

(program $constant_times_variable_get_variable ((A Type) (constant A)
                                                (variable A :list))
         :signature (A) A
         (
          (
           ($constant_times_variable_get_variable (* constant variable))

           variable
           )
          )
         )

(program $constant_times_variable_get_constant ((A Type) (constant A)
                                                (variable A :list))
         :signature (A) A
         (
          (
           ($constant_times_variable_get_constant (* constant variable))

           constant
           )
          )
         )

; program: $less_or_equal_literal
; args:
; - lhs A: A numeric literal.
; - rhs A: A numeric literal.
; return: The boolean value of the comparison lhs <= rhs.
(program $less_or_equal_literal ((A Type) (lhs A) (rhs A))
         :signature (A A) Bool
         (
          (
           ($less_or_equal_literal lhs rhs)

           (eo::or (eo::gt rhs lhs)
                   (eo::is_eq lhs rhs))
           )
          )
         )

; program: $less_or_equal_arith_terms
; args:
; - lhs A: An arbitrary arithmetic term.
; - rhs A: An arbitrary arithmetic term.
; return: >
;   Decides if `lhs` <= `rhs`. The criterion being:
;   - numeric literals are <= than uninterpreted constants
;   - for terms c1 * x and c2 * y, with x and y variables,
;     we follow the order eo::cmp y x
;   - between numeric literals we follo `$less_or_equal_literal`.
; note : >
;   PRE : { lhs and rhs are, either:
;           - numeric literals
;           - a product between numeric literals, or a numeric literal
;             and a variable (uninterpreted constants or uninterpreted 
;             functions applied to some value) }
(program $less_or_equal_arith_terms ((A Type) (lhs A) (lhs_a A) (lhs_term A :list)
                                     (rhs A) (rhs_a A) (rhs_term A :list)
                                     (term A :list))
         :signature (A A) Bool
         (
          (
           ($less_or_equal_arith_terms (* lhs_a term) (* rhs_a term))
           
           ($less_or_equal_literal lhs_a rhs_a)
           )

          (; { lhs_term != rhs_term }
           ($less_or_equal_arith_terms (* lhs_a lhs_term) (* rhs_a rhs_term))

           (eo::ite (eo::and ($is_numeric_literal lhs_term)
                             ($is_numeric_literal rhs_term))

                    (eo::and ($less_or_equal_literal lhs_a rhs_a)
                             ($less_or_equal_literal lhs_term rhs_term))

                    ; { not ($is_numeric_literal lhs_term)
                    ;   or 
                    ;   not ($is_numeric_literal rhs_term) }
                    (eo::ite ($is_numeric_literal lhs_term)

                             true

                             ; { not ($is_numeric_literal lhs_term) }
                             (eo::ite ($is_numeric_literal rhs_term)

                                      false

                                      ; { not ($is_numeric_literal rhs_term) }
                                      (eo::cmp rhs_term lhs_term))))
           )

          (; { lhs_term is not a product }
           ($less_or_equal_arith_terms lhs_term (* rhs_a rhs_term))

           true
           )

          (; { rhs_term is not a product }
           ($less_or_equal_arith_terms (* lhs_a lhs_term) rhs_term)

           false
           )

          (; { lhs and rhs are numeric literals }
           ($less_or_equal_arith_terms lhs rhs)

           ($less_or_equal_literal lhs rhs)
           )
          )
         )

; program: $get_lesser_arith_term
; args:
; - term A: An arithmetic term.
; return: The lesser summand in `term`, according to `$less_or_equal_literal`.
; note : >
;   PRE : { `term` is of the form x_1 + ... + x_n, where each x_i is, either,
;           l, l_1 * l_2, l * x, where l, l_1 and l_2 are numeric literals,
;           and x is a variable (a term involving uninterpreted constants). }
(program $get_lesser_arith_term ((A Type) (lhs A) (rhs A :list))
         :signature (A) A
         (
          (
           ($get_lesser_arith_term (+ lhs rhs))

           (eo::define 
            (
             (lesser ($get_lesser_arith_term rhs))
             )

            (eo::ite ($less_or_equal_literal lhs lesser)

                     lhs

                     lesser))
           )

          
          (; { lhs is a single summand }
           ($get_lesser_arith_term lhs)

           lhs
           )
          )
         )

; program: $reorder_arith_term
; args:
; - term A: An arithmetic term.
; return: >
;   A term obtained from reordering `term`, according to `$less_or_equal_literal`.
;   It implements a simple insertion-sort.
; note : >
;   PRE : { `term` is of the form x_1 + ... + x_n, where each x_i is, either,
;           l, l_1 * l_2, l * x, where l, l_1 and l_2 are numeric literals,
;           and x is a variable (a term involving uninterpreted constants). }
(program $reorder_arith_term ((A Type) (lhs A) (rhs A :list))
         :signature (A) A
         (
          (
           ($reorder_arith_term (+ lhs rhs))

           (eo::define 
            (
             (lesser ($get_lesser_arith_term rhs))
             )

            (eo::ite ($less_or_equal_literal lhs lesser)

                     ($f_list_cons + lhs
                                   ($reorder_arith_term
                                    ($f_list_remove_elem + rhs lesser 0)))

                     ; { not ($less_or_equal_literal lhs lesser) }
                     ($f_list_cons + lesser
                                   ($reorder_arith_term
                                    ($f_list_cons +
                                                  lhs
                                                  ($f_list_remove_elem
                                                   +
                                                   rhs 
                                                   lesser
                                                   0))))))
           )

          (; { lhs is a single summand }
           ($reorder_arith_term lhs)

           lhs
           )
          )
         )

; program: $small_step_evaluate_arith_term
; args:
; - term A: An arbitrary term representing a possible undefined numeric value.
; return: >
;   Returns a numeric expression that results from "evaluating" `term`: that is,
;   implements the denotational semantics of the expression `term`.
; note: >
;   PRE : { `term` is normalized according to `$normalize_arith_term` }
(program $small_step_evaluate_arith_term ((A Type) (lhs A) (rhs A :list) (term A))
         :signature (A) A
         (; Addition.
          (
           ($small_step_evaluate_arith_term (+ 0.0 rhs))
           
           ($small_step_evaluate_arith_term rhs)
           )

          (
           ($small_step_evaluate_arith_term (+ 0 rhs))
           
           ($small_step_evaluate_arith_term rhs)
           )

          (
           ($small_step_evaluate_arith_term (+ 0/1 rhs))
           
           ($small_step_evaluate_arith_term rhs)
           )

          (
           ($small_step_evaluate_arith_term (+ lhs rhs))
           
           (eo::ite (eo::and ($is_numeric_literal lhs)
                             ($is_numeric_literal rhs))

                     (eo::add (eo::to_q lhs) 
                              (eo::to_q rhs))
                     
                     ; { not ($is_numeric_literal lhs_evaluated)
                     ;   or
                     ;   not ($is_numeric_literal rhs_evaluated)) }
                     
                     ; Cases where we need to reason over the right term
                     (eo::ite (eo::is_eq 0 rhs)
                              ; Case (+ lhs 0)
                              lhs
                              ; { not (eo::is_eq 0 rhs) }
                              (eo::ite (eo::and ($is_constant_times_variable lhs)
                                                ($is_constant_times_variable rhs))

                                       (eo::define
                                        (
                                         (lhs_variable ($constant_times_variable_get_variable lhs))
                                         (rhs_variable ($constant_times_variable_get_variable rhs))
                                         )

                                        (eo::ite (eo::is_eq lhs_variable 
                                                            rhs_variable)

                                                 ; { case lhs = * c1 variable and
                                                 ;   rhs = * c2 variable }
                                                 (eo::define
                                                  (
                                                   (lhs_constant 
                                                    ($constant_times_variable_get_constant 
                                                     lhs))

                                                   (rhs_constant 
                                                    ($constant_times_variable_get_constant 
                                                     rhs))
                                                   )
                              
                                                  ($f_list_cons 
                                                   *

                                                   ($f_list_cons 
                                                    + 
                                                    lhs_constant
                                                    rhs_constant)

                                                   lhs_variable))

                                                 ; { not (eo::is_eq lhs_variable 
                                                 ;        rhs_variable)}
                                                 (+ lhs rhs)))

                                       ; { not ($is_constant_times_variable lhs)
                                       ;   or
                                       ;   not ($is_constant_times_variable rhs)}
                                       (+ lhs rhs))))
           )

          ; Multiplication.
          (
           ($small_step_evaluate_arith_term (* 0.0 rhs))
           
           0.0
           )

          (
           ($small_step_evaluate_arith_term (* 0 rhs))
           
           0
           )

          (
           ($small_step_evaluate_arith_term (* 0/1 rhs))
           
           0
           )

          (
           ($small_step_evaluate_arith_term (* 1.0 rhs))

           (eo::ite ($is_uninterpreted_constant rhs)
                    ; We keep the shape of the term, for future opportunities
                    ; of reduction.
                    (* 1.0  rhs)

                    ; { not ($is_uninterpreted_constant rhs) }
                    ($small_step_evaluate_arith_term rhs))
           )

          (
           ($small_step_evaluate_arith_term (* 1 rhs))
           
           (eo::ite ($is_uninterpreted_constant rhs)
                    ; We keep the shape of the term, for future opportunities
                    ; of reduction.
                    (* 1  rhs)

                    ; { not ($is_uninterpreted_constant rhs) }
                    ($small_step_evaluate_arith_term rhs))
           )

          (
           ($small_step_evaluate_arith_term (* (- 1.0) rhs))

           (eo::ite ($is_uninterpreted_constant rhs)
                    ; We keep the shape of the term, for future opportunities
                    ; of reduction.
                    (* (- 1.0)  rhs)

                    ; { not ($is_uninterpreted_constant rhs) }
                    ($small_step_evaluate_arith_term (- rhs)))
           )

          (
           ($small_step_evaluate_arith_term (* (- 1) rhs))

           (eo::ite ($is_uninterpreted_constant rhs)
                    ; We keep the shape of the term, for future opportunities
                    ; of reduction.
                    (* (- 1)  rhs)

                    ; { not ($is_uninterpreted_constant rhs) }
                    ($small_step_evaluate_arith_term (- rhs)))
           )

          (
           ($small_step_evaluate_arith_term (* lhs rhs))

           (eo::ite (eo::and ($is_numeric_literal lhs)
                             ($is_numeric_literal rhs))

                     (eo::mul (eo::to_q lhs) 
                              (eo::to_q rhs))

                     ; { not ($is_numeric_literal lhs_evaluated)
                     ;   or
                     ;   not ($is_numeric_literal rhs_evaluated)) }
                     (eo::ite (eo::is_eq rhs 0)
                              ; Case (* lhs 0.0)
                              0

                              ; {not (eo::is_eq rhs_evaluated 0)}
                              (eo::ite (eo::is_eq rhs 1)
                                       ; Case (* lhs 1)
                                       (eo::ite ($is_uninterpreted_constant lhs)

                                                (* 1 lhs)

                                                ; { not ($is_uninterpreted_constant rhs) }
                                                lhs)

                                       ; { not (eo::is_eq rhs_evaluated 1) }
                                       (eo::ite (eo::is_eq rhs -1)
                                                ; Case (* lhs (- 1.0))
                                                (eo::ite ($is_uninterpreted_constant lhs)

                                                         (* -1 lhs)

                                                         ; { not ($is_uninterpreted_constant rhs) }
                                                         (- lhs))

                                                ; { (eo::is_eq rhs_evaluated -1) }
                                                 ($f_list_cons * lhs rhs)))))
           )

          ; Negative numbers
          (
           ($small_step_evaluate_arith_term (- (- term)))

           ($small_step_evaluate_arith_term term)
           )

          (
           ($small_step_evaluate_arith_term (- term))

           (eo::ite ($is_numeric_literal term)

                     (eo::mul (eo::to_q -1)
                              (eo::to_q term))

                     (- term))
           )

          (
           ($small_step_evaluate_arith_term term)

           term
           )
          )
         )

; program: $evaluate_arith_term
; args:
; - $evaluate_arith_term nil:
; return:
(program $evaluate_arith_term ((A Type) (lhs A) (rhs A :list) (term A)
                               (op (-> A A A)))
         :signature (A) A
         (
          (
           ($evaluate_arith_term (op lhs rhs))

           (eo::define 
            (
             (lhs_evaluated ($evaluate_arith_term lhs))
             
             (rhs_evaluated ($evaluate_arith_term rhs))
             )

            (eo::define 
             (
              (term_evaluated ($small_step_evaluate_arith_term
                                ($f_list_cons op 
                                              lhs_evaluated
                                              rhs_evaluated)))
              )

             (eo::ite (eo::is_eq term_evaluated
                                 ($f_list_cons op 
                                               lhs_evaluated
                                               rhs_evaluated))

                      ; No progress made, we give up.
                      term_evaluated

                      ; { not (eo::is_eq term_evaluated
                      ;       ($f_list_cons op 
                      ;                     lhs_evaluated
                      ;                     rhs_evaluated)) }
                      ; Some progress made, we try again.
                      ($evaluate_arith_term term_evaluated))))
          )
         
         (
          ($evaluate_arith_term term)

           (eo::define 
            (
             (term_evaluated ($small_step_evaluate_arith_term term))
             )

            (eo::ite (eo::is_eq term_evaluated term)

                     ; No progress made, we give up.
                     term_evaluated

                     ; { not (eo::is_eq term_normalized term) }
                     ; Some progress made, we try again.
                     ($evaluate_arith_term term_evaluated)))
           )
         )
         )

; program: $small_step_normalize_arith_term
; args:
; - term A: An arbitrary arithmetic term.
; return: >
;   The "normalized" form of `term`:
;   - the resulting term is an addition of terms of the following form:
;     + numeric literals
;     + a product between numeric literals, or a numeric literal
;       and a variable (uninterpreted constants or uninterpreted 
;       functions applied to some value)
;   - sub-terms do not contain leading unary "-"
; note: >
;   It is inspired in the "normalization" algorithm introduced in the paper 
;   "Checking Linear Integer Arithmetic Proofs in Lambdapi", by Alessio 
;   Coltellacci & Stephan Merz.
(program $small_step_normalize_arith_term ((A Type) (lhs A) (variable A :list)
                                (c1 A) (c2 A)
                                (rhs A :list) (rhs_lhs A) (rhs_rhs A :list)
                                (term A))
         :signature (A) A
         (
          (; Getting rid of leading unary "-".
           ($small_step_normalize_arith_term (- (+ lhs rhs)))

           ($f_list_cons + (- lhs) (- rhs))
           )

          (; { term is not an addition or multiplication }
           ($small_step_normalize_arith_term (- (* lhs rhs)))

           ($f_list_cons * (- lhs) rhs)
           )

          (; { term is not an addition or multiplication }
           ($small_step_normalize_arith_term (- (- term)))

           term
           )

          (; { term is not an addition or multiplication }
           ($small_step_normalize_arith_term (- term))

           ($f_list_cons * -1 term)
           )

          (; { rhs is not an addition }
           ($small_step_normalize_arith_term (* lhs rhs))

           ; Check for case 
           ; (* lhs (+ rhs_lhs rhs_rhs)) = (+ (* lhs rhs_lhs) (* lhs rhs_rhs))
           (eo::ite ($is_addition rhs)
                    ; We will try to distribute lhs.
                    (eo::define
                     (
                      (rhs_lhs ($addition_get_lhs rhs))
                      (rhs_rhs ($addition_get_rhs rhs))
                      )

                     ($f_list_cons + 
                                   ($f_list_cons * lhs rhs_lhs)
                                   ($f_list_cons * lhs rhs_rhs)))

                    ; { not ($is_addition rhs) }
                    (eo::ite ($is_addition lhs)

                             ; We commute, to try to apply our
                             ; distributivity rule.
                             ; Cases of the form:
                             ; (* (+ rhs_lhs rhs_rhs) c) = (* c (+ rhs_lhs rhs_rhs))
                             ($f_list_cons * rhs lhs)

                             ; { not ($is_numeric_literal rhs)
                             ;   or ($is_numeric_literal lhs) }
                             ($f_list_cons * lhs rhs)))
           )

          (; { term is not an addition, multiplication or unary substraction }
           ($small_step_normalize_arith_term term)

           term
           )
          )
         )


; program: $normalize_arith_term
; args:
; - term A: An arithmetic term.
; return: >
;   The result of normalizing `term` applying `$small_step_normalize_arith_term`
;   as much as possible. Implements a rewriting machine that controls how to
;   apply `$small_step_normalize_arith_term`.
;   Left-to-right eager normalization order:
;   - For a term op lhs rhs, we normalize lhs, in small-step fashion, until
;     it cannot be further normalized. We continue with rhs, and only then
;     with the whole resulting term.
;   - Context-sensitive rewriting rules: 
(program $normalize_arith_term ((A Type) (lhs A) (rhs A)
                                (op (-> A A A)) (term A))
         :signature (A) A
         (
          (
           ($normalize_arith_term (op lhs rhs))
           
           (eo::define 
            (
             (lhs_normalized ($small_step_normalize_arith_term lhs))
             )

            (eo::ite (eo::is_eq lhs_normalized lhs)

                     ; lhs already normalize
                     (eo::define 
                      (
                       (rhs_normalized ($small_step_normalize_arith_term rhs))
                       )

                      (eo::ite (eo::is_eq rhs_normalized rhs)

                               ; rhs already normalized, we continue with the
                               ; whole term.
                               (eo::define 
                                (
                                 (term_normalized ($small_step_normalize_arith_term
                                                   (op lhs rhs)))
                                 )

                                (eo::ite (eo::is_eq term_normalized 
                                                    (op lhs rhs))

                                         ; No more progress during normalization.
                                         ; We give up.
                                         term_normalized

                                         ; { not (eo::is_eq term_normalized 
                                         ;          (op lhs rhs)}
                                         ; Some progress made, we try again.
                                         ($normalize_arith_term
                                          term_normalized)))

                               ; { not (eo::is_eq rhs_normalized rhs) }
                               ; Some progress made, we try again.
                               ($normalize_arith_term
                                (op lhs_normalized rhs_normalized))))

                     ; { not (eo::is_eq lhs_normalized lhs) }
                     ; Some progress made, we try again.
                     ($normalize_arith_term
                      (op lhs_normalized rhs))))
           )
          
          ;; (; { term != op lhs rhs }
          ;;  ($normalize_arith_term term)

          ;;  (eo::define 
          ;;   (
          ;;    (term_normalized ($small_step_normalize_arith_term term))
          ;;    )

          ;;   (eo::ite (eo::is_eq term_normalized term)
          ;;            ; No progress made.
          ;;            (eo::ite ($is_uninterpreted_constant term)
          ;;                     ; Context-dependent rule: we convert a variable
          ;;                     ; x into (* 1 x) only when it
          ;;                     ($f_list_cons * 1 term)

          ;;                     ; { not ($is_uninterpreted_constant rhs) 
          ;;                     term_normalized)

          ;;            ; { not (eo::is_eq term_normalized term) }
          ;;            ; Some progress made, we try again.
          ;;            ($normalize_arith_term term_normalized)))
          ;;  )
          )
         )
